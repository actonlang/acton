# Copyright (C) 2019-2021 Data Ductus AB
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

######################################### Type and class hierarchy ###############################################

protocol Eq:
    @static
    __eq__          : (Self,Self) -> bool
    @static
    __ne__          : (Self,Self) -> bool
    
    def __ne__(a,b):
        return not (a == b)
====>
"typeclass" Eq[S]:
    __eq__          : (S,S) -> bool
    __ne__          : (S,S) -> bool

    def __ne__(a,b):
        return not (a == b)
====>
class Eq[S]():
    __eq__          : (S,S) -> bool
    __ne__          : (S,S) -> bool

    def __ne__(w,a,b):
        return not w.__eq__(a,b)
    
-----------------------------------------------------------------

class Fruit (Eq):
    def __eq__(a, b):
        return a.weight == b.weight

class Apple (Fruit):
    def __eq__(a, b):
        return Fruit.__eq__(a,b) and a.appleness == b.appleness

class Orange (Fruit):
    def __eq__(a, b):
        return Fruit.__eq__(a,b) and a.orangeness == b.orangeness

a, b : Apple
a == b
Eq.__eq__(a,b)
x, y : Orange
x == y
Eq.__eq__(x,y)
f1 : Fruit = a
f2 : Fruit = x
f1 == f2
a == x
Eq.__eq__(a,x)
====>
class Fruit:
    ...
"instance" Eq[Fruit]:
    def __eq__(a, b):
        return a.weight == b.weight
class Apple (Fruit):
    ...
"instance" Eq[Apple]:
    def __eq__(a, b):
        return Fruit.__eq__(a,b) and a.appleness == b.appleness
class Orange (Fruit):
    ...
"instance" Eq[Orange]:
    def __eq__(a, b):
        return Fruit.__eq__(a,b) and a.orangeness == b.orangeness
====>
class Fruit:
    weight : int
    
class Eq_Fruit[S(Fruit)] (Eq[S]):
    def __eq__(w, a:S, b:S):
        return Eq_int.__eq__(a.weight, b.weight)

class Apple (Fruit):
    appleness : str

class Eq_Apple[S(Apple)] (Eq_Fruit[S]):
    def __eq__(w, a:S, b:S):
        return Eq_Fruit.__eq__(a,b) and Eq_str(a.appleness, b.appleness)

class Orange (Fruit):
    orangeness : str

class Eq_Orange[S(Orange)] (Eq[S]):
    def __eq__(w, a:S, b:S):
        return Eq_Fruit.__eq__(a,b) and Eq_str(a.orangeness, b.orangeness)

a, b : Apple
Eq_Apple.__eq__(a,b)
x, y : Orange
Eq_Orange.__eq__(x,y)
f1 : Fruit = a
f2 : Fruit = x
Eq_Fruit.__eq__(f1,f2)
Eq_Fruit.__eq__(a,x)

-----------------------------------------------------------------

protocol Hashable (Eq):
    __hash__        : () -> int
====>
"typeclass" (Eq[S]) => Hashable[S]:
    __hash__        : (S) -> int
====>
class Hashable[S] (Eq[S]):
    __hash__        : (S) -> int

-----------------------------------------------------------------

class Apa(Hashable):
    x : int
    def apa(self, y):
        return self.hash() if y==0 else y
    def hash(self):
        return self.x + self.apa(1)

====>

class Apa():
    x : int
    def apa(self, w:Hashable[Apa], y):
        return w.hash(self) if y==0 else y

class Hashable_Apa (Hashable[Apa]):
    def hash(w, self):
        return self.x + self.apa(w,1)

-----------------------------------------------------------------

class MyClass (Hashable):
    attr1 : int
    def __eq__(a, b):
        return a.hash() == b.hash()
    def hash(self):
        return self.attr1
    my_method: ()->int
    def my_method(self):
        return self.hash()
        
class MySubClass (MyClass):
    attr2 : int
    def hash(self):
        return fancy_hash(self.attr2)

x, y : MySubClass
z : MyClass = y

x == y  -->  Eq.__eq__(x,y)  -->  MySubClass.hash(x) == MySubClass.hash(y)  -->  fancy_hash(x.attr2) == fancy_hash(y.attr2)
x == z  -->  Eq.__eq__(x,z)  -->  MyClass.hash(x) == MyClass.hash(z)        -->  x.attr1 == z.attr1

y.my_method()  -->  MySubClass.my_method(y)  -->  MySubClass.hash(y)  -->  fancy_hash(y.attr2)
z.my_method()  -->  MySubClass.my_method(z)  -->  MyClass.hash(z)     -->  z.attr1

====>
class MyClass:
    def my_method(self):
        return hash(self)
"instance" Hashable[MyClass]:
    def __hash__(self):
        return self.attr1
"instance" Eq[MyClass]:
    def __eq__(a, b):
        return hash(a) == hash(b)
class MySubClass (MyClass):
    pass
"instance" Hashable[MySubClass]:
    def __hash__(self):
        return fancy_hash(self.attr2)
====>

class MyClass:
    attr1 : int
    my_method : (Hashable(Self))->int                   # Covariant in Self, since Hashable is a contravariant operator
    def my_method(self, w:Hashable[Self]):              # Note: w:Hashable[MyClass] would render ny_method uninheritable in MySubClass
        return w.hash(self)

class MySubClass (MyClass):
    attr2 : int

class Hashable_MyClass[S(MyClass)] (Hashable[S]):
    def __eq__(w, a:S, b:S):
        return Eq_int.__eq__(w.hash(a), w.hash(b))
    def hash(w, self:S):
        return self.attr1
class Hashable_MySubClass[S(MySubClass)] (Hashable_MyClass[S]):
    def hash(w, self:S):
        return fancy_hash(self.attr2)

x, y : MySubClass
z : MyClass = y

w0 : Hashable_MyClass
w1 : Hashable_MySubClass

x == y  -->  w1.__eq__(x,y)  -->  Hashable_MySubClass.hash(w1,x) == Hashable_MySubClass.hash(w1,y)  -->  fancy_hash(x.attr2) == fancy_hash(y.attr2)
x == z  -->  w0.__eq__(x,z)  -->  Hashable_MyClass.hash(w0,x) == Hashable_MyClass.hash(w0,z)        -->  x.attr1 == z.attr1

y.my_method()  -->  y.my_method(w1)  -->  MySubClass.my_method(y,w1)  -->  Hashable_MySubClass.hash(w1,y)  -->  fancy_hash(y.attr2)
z.my_method()  -->  z.my_method(w2)  -->  MySubClass.my_method(z,w2)  -->  Hashable_MyClass.hash(w2,z)     -->  z.attr1

# P1          ===     Obj(Self) [hash:Int, mymeth:Int, a1:Int]
# Class(P1)   ===     [new:P1, hash:All(Self<P1)Self->Int, mymeth:All(Self<P1)Self->Int]
# p1_class    ===     [new    = sigma(z:Class(P1)) obj(Self=P1) [hash = sigma(s:Self)z.hash(Self)(s), 
#                                                                mymeth = sigma(s:Self)z.mymeth(Self)(s), 
#                                                                a1 = sigma(s:Self)1],
#                      hash   = lambda(Self<P1) lambda(s:Self) s.a1,
#                      mymeth = lambda(Self<P1) lambda(s:Self) s.hash]
#
# P2          ===     Obj(Self) [hash:Int, mymeth:Int, a1:Int, a2:Int]
# Class(P2)   ===     [new:P2, hash:All(Self<P2)Self->Int, mymeth:All(Self<P2)Self->Int]
# p2_class    ===     [new    = sigma(z:Class(P2)) obj(Self=P2) [hash = sigma(s:Self)z.hash(Self)(s), 
#                                                                mymeth = sigma(s:Self)z.mymeth(Self)(s), 
#                                                                a1 = sigma(s:Self)1, 
#                                                                a2 = sigma(s:Self)2],
#                      hash   = lambda(Self<P2) lambda(s:Self) fancy_hash(s.a2)
#                      mymeth = p1_class.mymeth]

-----------------------------------------------------------------
    
protocol Ord (Eq):
    @static
    __lt__          : (Self,Self) -> bool
    @static
    __le__          : (Self,Self) -> bool
    @static
    __gt__          : (Self,Self) -> bool
    @static
    __ge__          : (Self,Self) -> bool

    def __le__(a,b):
        return a < b or a == b              # return Ord.__lt__(a,b) or Eq.__eq__(a,b)
    def __gt__(a,b):
        return b < a                        # return Ord.__lt__(b,a)
    def __ge__(a,b):
        return b <= a                       # return Ord.__le__(b,a)
====>
"typeclass" (Eq[S]) => Ord[S]:
    __lt__          : (S,S) -> bool
    __le__          : (S,S) -> bool
    __gt__          : (S,S) -> bool
    __ge__          : (S,S) -> bool

    def __le__(a,b):
        return a < b or a == b
    def __gt__(a,b):
        return b < a
    def __ge__(a,b):
        return b <= a
====>
class Ord[S] (Eq[S]):
    __lt__          : (S,S) -> bool
    __le__          : (S,S) -> bool
    __gt__          : (S,S) -> bool
    __ge__          : (S,S) -> bool

    def __le__(w,a,b):
        return w.__lt__(a,b) or w.__eq__(a,b)
    def __gt__(w,a,b):
        return w.__lt__(b,a)
    def __ge__(w,a,b):
        return w.__le__(b,a)

-----------------------------------------------------------------

extension int (Eq):
    def __eq__(a:int, b:int) -> bool:
        return primeqint(a,b)
extension int (Ord):
    def __lt__(a:int, b:int) -> bool:
        return primltint(a,b)
    def __eq__(a:int, b:int) -> bool:             # Overrides int._eq_
        return primeqint(a,b)
====>
"instance" Eq[int]:
    def __eq__(a:int, b:int) -> bool:
        return primeqint(a,b)
"instance" Ord[int]:
    def __lt__(a:int, b:int) -> bool:
        return primltint(a,b)
    def __eq__(a:int, b:int) -> bool:
        return primeqint(a,b)
====>
class Eq_int (Eq[int]):
    def __eq__(w, a:int, b:int) -> bool:
        return primeqint(a,b)
class Ord_int (Ord[int]):
    def __lt__(w, a:int, b:int) -> bool:
        return primltint(a,b)
w1 : Eq[int] = Eq_int()
w2 : Ord[int] = Ord_int()

-----------------------------------------------------------------

extension int (Ord):                                   # ALTERNATIVELY: A JOINT EXTENSION int (Ord) AND int (Eq)
    def __eq__(a:int, b:int) -> bool:
        return primeqint(a,b)
    def __lt__(a:int, b:int) -> bool:
        return primltint(a,b)
====>
"instance" Ord[int]:
    def __eq__(a:int, b:int) -> bool:
        return primeqint(a,b)
    def __lt__(a:int, b:int) -> bool:
        return primeqint(a,b)
====>
class Ord_int (Ord[int]):
    def __eq__(w, a:int, b:int) -> bool:
        return primeqint(a,b)
    def __lt__(w, a:int, b:int) -> bool:
        return primeqint(a,b)
w2 : Ord[int] = Ord_int()
w1 : Eq[int] = w2

-----------------------------------------------------------------

protocol SupportsInt:
    __int__         : () -> int
====>
"typeclass" SupportsInt[S]:
    __int__         : (S) -> int
====>
class SupportsInt[S]():
    __int__         : (S) -> int

-----------------------------------------------------------------

extension int (SupportsInt):
    def __int__(self:int) -> int
        return self
====>
"instance" SupportsInt[int]:
    def __int__(self:int) -> int
        return self
====>
class SupportsInt_int (SupportsInt[int]):
    def __int__(w, self:int) -> int
        return self

-----------------------------------------------------------------

protocol SupportsFloat:
    __float__       : () -> float
====>
"typeclass" SupportsFloat[S]:
    __float__       : (S) -> float
====>
class SupportsFloat[S]():
    __float__       : (S) -> float

-----------------------------------------------------------------
    
protocol SupportsComplex:
    __complex__     : () -> complex
====>
"typeclass" SupportsComplex[S]:
    __complex__     : (S) -> complex
====>
class SupportsComplex[S]():
    __complex__     : (S) -> complex

-----------------------------------------------------------------

protocol SupportsBytes:
    __bytes__       : () -> bytes
====>
"typeclass" SupportsBytes[S]:
    __bytes__       : (S) -> bytes
====>
class SupportsBytes[S]():
    __bytes__       : (S) -> bytes

-----------------------------------------------------------------

protocol Logical:
    @static
    __and__         : (Self,Self) -> Self
    @static
    __or__          : (Self,Self) -> Self
    @static
    __xor__         : (Self,Self) -> Self
====>
"typeclass" Logical[S]:
    __and__         : (S,S) -> S
    __or__          : (S,S) -> S
    __xor__         : (S,S) -> S
====>
class Logical[S]():
    __and__         : (S,S) -> S
    __or__          : (S,S) -> S
    __xor__         : (S,S) -> S

-----------------------------------------------------------------

protocol Plus:
    @static
    __add__         : (Self,Self) -> Self
====>
"typeclass" Plus[S]:
    __add__         : (S,S) -> S
====>
class Plus[S]():
    __add__         : (S,S) -> S

-----------------------------------------------------------------

protocol Minus:
    @static
    __sub__         : (Self,Self) -> Self
====>
"typeclass" Minus[S]:
    __sub__         : (S,S) -> S
====>
class Minus[S]():
    __sub__         : (S,S) -> S

-----------------------------------------------------------------

protocol Number (Ord, Plus, Minus):
    __pos__         : () -> Self
    __neg__         : () -> Self
    @static
    __mul__         : (Self,Self) -> Self
    @static
    __pow__         : (Self,Self) -> Self
    def __sub__(a,b):
        return a + (-b)
====>
"typeclass" (Ord[S], Plus[S], Minus[S]) => Number[S]:
    __pos__         : (S) -> S
    __neg__         : (S) -> S
    __mul__         : (S,S) -> S
    __pow__         : (S,S) -> S
    def __sub__(a:S, b:S):
        return __add__(a, __neg__(b))
    
====>
class Plus_Number[S] (Plus[S]):
    _Number         : Number[S]
    def __add__(w, a, b):
        return w._Number.__add__(a, b)
class Minus_Number[S] (Minus[S]):
    _Number         : Number[S]
    def __sub__(w, a:S, b:S):                       # if __sub__ is NOT inherited from Minus
        return w._Number.__sub__(a, b)
class Number[S] (Ord[S]):
    _Plus           : Plus[S]
    _Minus          : Minus[S]
    __add__         : (S,S) -> S
    __sub__         : (S,S) -> S
    __pos__         : (S) -> S
    __neg__         : (S) -> S
    __mul__         : (S,S) -> S
    __pow__         : (S,S) -> S
    def __sub__(w, a, b):
        return w.__add__(a, w.__neg__(b))


-----------------------------------------------------------------

extension int (Number):
    def __pos__(self:int) -> int:
        return self
    def __neg__(self:int) -> int:
        return primnegint(self)
    def __add__(a:int, b:int) -> int:
        return primaddint(a,b)
    def __sub__(a:int, b:int) -> int:
        return primaddint(a,b)
    def __mul__(a:int, b:int) -> int:
        return primmulint(a,b)
    def __eq__(a:int, b:int) -> bool:
        return primeqint(a,b)
    def __lt__(a:int, b:int) -> bool:
        return primltint(a,b)
====>
"instance" Number[int]:
    def __pos__(self:int) -> int:
        return self
    def __neg__(self:int) -> int:
        return primnegint(self)
    def __add__(a:int, b:int) -> int:
        return primaddint(a,b)
    def __sub__(a:int, b:int) -> int:
        return primaddint(a,b)
    def __mul__(a:int, b:int) -> int:
        return primmulint(a,b)
    def __eq__(a:int, b:int) -> bool:
        return primeqint(a,b)
    def __lt__(a:int, b:int) -> bool:
        return primltint(a,b)

====>
class Plus_int (Plus_Number[int]):
    def __add__(w, a:int, b:int) -> int:
        return primaddint(a,b)
class Minus_int (Minus_Number[int]):
    def __sub__(wit, a:int, b:int) -> int:
        return primsubint(a,b)
    # def __sub__(w, a:S, b:S):                                     # if not overridden, inherited from Minus_Number
    #     return w._Number._Plus.__add__(a, w._Number.__neg__(b))
class Number_int (Number[int]):
    def __init__(w):
        w._Plus = Plus_int(w)
        w._Minus = Minus_int(w)
    def __pos__(e, self:int) -> int:
        return self
    def __neg__(w, self:int) -> int:
        return primnegint(self)
    def __mul__(w, a:int, b:int) -> int:
        return primmulint(a,b)
    def __eq__(w, a:int, b:int) -> bool:
        return primeqint(a,b)
    def __lt__(w, a:int, b:int) -> bool:
        return primltint(a,b)

-----------------------------------------------------------------

protocol SupportsAbs:
    __abs__         : () -> Self
====>
"typeclass" SupportsAbs[S]:
    __abs__         : (S) -> S
====>
class SupportsAbs[S]():
    __abs__         : (S) -> S

-----------------------------------------------------------------

protocol Complex (Number, SupportsAbs, SupportsComplex):
    @static
    __fromcomplex__ : (complex) -> Self
    @static
    __div__         : (Self,Self) -> Self
    real            : () -> Real
    imag            : () -> Real
    conjugate       : () -> Self
====>
"typeclass" (Number[S],SupportsAbs[S],SupportsComplex[S]) => Complex[S]:
    __fromcomplex__ : (complex) -> S
    __div__         : (S,S) -> S
    real            : (S) -> EXISTS[T,Real[T]]
    imag            : (S) -> EXISTS[T,Real[T]]
    conjugate       : (S) -> S
====>
class SupportsAbs_Complex[S] (SupportsAbs[S]):
    _Complex        : Complex[S]
class SupportsComplex_Complex[S] (SupportsComplex[S]):
    _Complex        : Complex[S]
class Complex[S] (Number[S]):
    _SuppAbs        : SupportsAbs[S]
    _SuppComplex    : SupportsComplex[S]

    __fromcomplex__ : (complex) -> S
    __div__         : (S,S) -> S
    real            : (S) -> EXISTS[T,Real[T]]
    imag            : (S) -> EXISTS[T,Real[T]]
    conjugate       : (S) -> S

-----------------------------------------------------------------

protocol SupportsRound:
    __round__       : () -> int
====>
"typeclass" SupportsRound[S]:
    __round__       : (S) -> int
====>
class SupportsRound[S]():
    __round__       : (S) -> int

-----------------------------------------------------------------

protocol Real (Complex, SupportsRound, SupportsFloat):
    @static
    __fromfloat__   : (float) -> Self
    __trunc__       : () -> Integral
    __floor__       : () -> Integral
    __ceil__        : () -> Integral
    @static
    __divmod__      : (Self,Self) -> (Self,Self) 
    @static
    __floordiv__    : (Self,Self) -> Integral    
    @static
    __mod__         : (Self,Self) -> Self        

    def __complex__(a):
        return complex(float(a))
    def real(a):
        return fromfloat(float(a))
    def imag(a):
        return fromfloat(0.0)
    def conjugate(a):
        return a
    def divmod(a,b):
        return (a//b, a%b)
====>
"typeclass" (Complex[S],SupportsRound[S],SupportsFloat[S]) => Real[S]:
    __fromfloat__   : (float) -> S
    __trunc__       : (S) -> EXISTS[T,Intergral[T]]
    __floor__       : (S) -> EXISTS[T,Intergral[T]]
    __ceil__        : (S) -> EXISTS[T,Intergral[T]]
    __divmod__      : (S,S) -> (S,S)
    __floordiv__    : (S,S) -> EXISTS[T,Intergral[T]]
    __mod__         : (S,S) -> S

    def __complex__(a):
        return complex(float(a))
    def real(a):
        return a
    def imag(a):
        return 0
    def conjugate(a):
        return a
    def divmod(a,b):
        return (a//b, a%b)
====>
class Plus_Real[S] (Plus_Complex[S]):
    _Real           : Real[S]
class Minus_Real[S] (Minus_Complex[S]):
    _Real           : Real[S]
class SupportsAbs_Real[S] (SupportsAbs_Complex[S]):
    _Real           : Real[S]
class SupportsComplex_Real[S] (SupportsComplex_Complex[S]):
    _Real           : Real[S]
class SupportsRound_Real[S] (SupportsRound[S]):
    _Real           : Real[S]
class SupportsFloat_Real[S] (SupportsFloat[S]):
    _Real           : Real[S]
class Real[S] (Complex[S]):
    _SuppRound      : SupportsRound[S]
    _SuppFloat      : SupportsFloat[S]
    
    __fromfloat__   : (float) -> S
    __trunc__       : (S) -> EXISTS[T,Intergral[T]]
    __floor__       : (S) -> EXISTS[T,Intergral[T]]
    __ceil__        : (S) -> EXISTS[T,Intergral[T]]
    __divmod__      : (S,S) -> (S,S)
    __floordiv__    : (S,S) -> EXISTS[T,Intergral[T]]
    __mod__         : (S,S) -> S

    def __complex__(w,a):
        return w.__complex__(w.__float__(a))
    def real(cls,_w,a):
        return _w.__fromfloat__(cls.__float__(a))
    def imag(cls,_w,a):
        return _w.__fromfloat__(0.0)
    def conjugate(cls,a):
        return a
    def divmod(cls,a,b):
        return (cls.__floordiv__(a,b), cls.__mod__(a,b))

-----------------------------------------------------------------

protocol Rational (Real):
    numerator       : () -> Integral
    denominator     : () -> Integral
    
    def __float__(a):
        return numerator(a) / denominator(a)
====>
"typeclass" (Real[S]) => Rational[S]:
    numerator       : (Integral[T]) => (S) -> T
    denominator     : (Integral[T]) => (S) -> T

    def __float__(a):
        return numerator(a) / denominator(a)
====>
class Plus_Rational[S] (Plus_Real[S]):
    _Number         = Rational
class Minus_Rational[S] (Minus_Real[S]):
    _Number         = Rational
class SupportsAbs_Rational[S] (SupportsAbs_Real[S]):
    _Complex        = Rational
class SupportsComplex_Rational[S] (SupportsComplex_Real[S]):
    _Complex        = Rational
class SupportsRound_Rational[S] (SupportsRound_Real[S]):
    _Real           = Rational
class SupportsFLoat_Rational[S] (SupportsFLoat_Real[S])
    _Real           = Rational

    def __float__(cls,a):
        Int = Integral_int
        return Real_float.__div__(Int._SuppFloat.__float__(cls._Rational.numerator(Int,a)), 
                                  Int._SuppFloat.__float__(cls._Rational.denominator(Int,a)))

class Rational[S] (Real[S]):
    _Plus           = Plus_Rational
    _Minus          = Minus_Rational
    _SuppAbs        = SupportsAbs_Rational
    _SuppComplex    = SupportsComplex_Rational
    _SuppRound      = SupportsRound_Rational
    _SuppFloat      = SupportsFloat_Rational
    
    numerator       : (@Integral[T], S) -> T
    denominator     : (@Integral[T], S) -> T
    
-----------------------------------------------------------------

protocol Integral (Rational,SupportsInt,Logical):
    @static
    __fromint__     : (int) -> Self
    __index__       : () -> Self
    @static
    __lshift__      : (Self,Self) -> Self
    @static
    __rshift__      : (Self,Self) -> Self
    __invert__      : () -> Self
    
    def __index__(a):
        return int(a)
    def __lshift__(a,b):
        return fromint(int(a) << int(b))
    def __invert__(a):
        return fromint(~int(a))
    def __float__(a):
        return float(int(a))
    def numerator(a):
        return a
    def denominator(a):
        return 1
====>
"typeclass" (Rational[S],SupportsInt[S],Logical[S]) => Integral[S]:
    __fromint__     : (int) -> S
    __index__       : (S) -> S
    __lshift__      : (S,S) -> S
    __rshift__      : (S,S) -> S
    __invert__      : (S) -> S

    def __index__(a):
        return int(a)
    def __lshift__(a,b):
        return fromint(int(a) << int(b))
    def __float__(a):
        return float(int(a))
    def numerator(a):
        return a
    def denominator(a):
        return 1
====>
class Plus_Integral[S] (Plus_Rational[S]):
    _Number         = Integral
class Minus_Integral[S] (Minus_Rational[S]):
    _Number         = Integral
class SupportsAbs_Integral[S] (SupportsAbs_Rational[S]):
    _Complex        = Integral
class SupportsComplex_Integral[S] (SupportsComplex_Rational[S]):
    _Complex        = Integral
class SupportsRound_Integral[S] (SupportsRound_Rational[S]):
    _Real           = Integral
class SupportsFLoat_Integral[S] (SupportsFLoat_Rational[S])
    _Real           = Integral
class SupportsInt_Integral[S] (SupportsInt[S])
    _Integral       = Integral
class Logical_Integral[S] (Logical[S])
    _Integral       = Integral
class Integral[S] (Rational[S]):
    _Plus           = Plus_Integral
    _Minus          = Minus_Integral
    _SuppAbs        = SupportsAbs_Integral
    _SuppComplex    = SupportsComplex_Integral
    _SuppRound      = SupportsRound_Integral
    _SuppFloat      = SupportsFloat_Integral
    _SuppInt        = SupportsInt_Integral
    _Logical        = Logical_Integral
    
    @static
    __fromint__     : (int) -> S
    __index__       : (S) -> S
    __lshift__      : (S,S) -> S
    __rshift__      : (S,S) -> S
    __invert__      : (S) -> S

    def __index__(cls,a):
        return cls._SuppInt.__int__(a)
    def __lshift__(cls,a,b):
        return cls.__fromint__(Integral_int.__lshift__(cls._SuppInt.__int__(a), cls._SuppInt.__int__(b)))
    def __invert__(cls,a):
        return cls.__fromint__(Integral_int.__invert__(cls._SuppInt.__int__(a)))
    def __float__(cls,a):
        return Integral_int._SuppFloat.__float__(cls._SuppInt.__int__(a))
    def numerator(cls,_w,a):
        return _w.__fromint__(cls.__SuppInt.__int__(a))
    def denominator(cls,_w,a):
        return _w.__fromint__(0)

-----------------------------------------------------------------

extension int (Integral):
    def __fromint__(a):
        return a
    def __int__(self):
        return self
    def __and__(a,b):
        return prinandint(a,b)
====>    
"instance" Integral[int]:
    def __fromint__(a):
        return a
    def __int__(self):
        return self
    def __and__(a,b):
        return prinandint(a,b)
====>
class Plus_Rational_int (Plus_Rational[int]):
    _Number         = Integral_int
class Minus_Rational_int (Minus_Rational[int]):
    _Number         = Integral_int
class SupportsAbs_Integral_int (SupportsAbs_Integral[int]):
    _Complex        = Integral_int
class SupportsComplex_Integral_int (SupportsComplex_Integral[int]):
    _Complex        = Integral_int
class SupportsRound_Integral_int (SupportsRound_Integral[int]):
    _Real           = Integral_int
class SupportsFloat_Integral_int (SupportsFloat_Integral[int]):
    _Real           = Integral_int
class SupportsInt_Integral_int (SupportsInt_Integral[int]):
    _Integral       = Integral_int
    def __int__(cls,self):
        return self
class Logical_Integral_int (Logical_Integral[int]):
    _Integral       = Integral_int
    def __and__(cls,a,b):
        return prinandint(a,b)
class Integral_int (Integral[int]):
    _Plus           = Plus_Integral_int
    _Minus          = Minus_Integral_int
    _SuppAbs        = SupportsAbs_Integral_int
    _SuppComplex    = SupportsComplex_Integral_int
    _SuppRound      = SupportsRound_Integral_int
    _SuppFloat      = SupportsFloat_Integral_int
    _SuppInt        = SupportsInt_Integral_int
    _Logical        = Logical_Integral_int
    def __fromint__(cls,a):
        return a

-----------------------------------------------------------------

extension bool (Logical,Ord):
    def __and__(a,b):
        return b if a else False
    def __eq__(a,b):
        return primeqbool(a,b)
    def __lt__(a,b):
        return a == False and b == True
====>
"instance" Ord[bool]
    def __eq__(a,b):
        return primeqbool(a,b)
    def __lt__(a,b):
        return a == True and b == False
"instance" Logical[bool]:
    def __and__(a,b):
        return b if a else False
====>
class Ord_bool (Ord[bool]):
    _Logical = Logical_bool
    def __eq__(cls,a,b):
        return primeqbool(a,b)
    def __lt__(cls,a,b):
        return cls.__eq__(a,True) and cls.__eq__(b,False)
class Logical_bool (Logical[bool]):
    _Ord = Ord_bool
    def __and__(a,b):
        return b if a else False

-----------------------------------------------------------------

extension bool (Logical):
    def __and__(a,b):
        return b if a else False
extension bool (Ord):
    def __eq__(a,b):
        return primeqbool(a,b)
    def __lt__(a,b):
        return a == False and b == True
====>
"instance" Ord[bool]
    def __eq__(a,b):
        return primeqbool(a,b)
    def __lt__(a,b):
        return a == True and b == False
"instance" Logical[bool]:
    def __and__(a,b):
        return b if a else False
====>
class Ord_bool (Ord[bool]):
    def __eq__(cls,a,b):
        return primeqbool(a,b)
    def __lt__(cls,a,b):
        return cls.__eq__(a,True) and cls.__eq__(b,False)
class Logical_bool (Logical[bool]):
    def __and__(a,b):
        return b if a else False

-----------------------------------------------------------------

protocol IncrementalLogical[A] (Logical):
    __iand__        : !(A) -> None
    __ior__         : !(A) -> None
    __ixor__        : !(A) -> None
====>
"typeclass" (Logical[S]) => IncrementalLogical[S,A]:
    __iand__        : !(S,A) -> None
    __ior__         : !(S,A) -> None
    __ixor__        : !(S,A) -> None
====>
class IncrementalLogical[S,A] (Logical[S])
    __iand__        : !(S,A) -> None
    __ior__         : !(S,A) -> None
    __ixor__        : !(S,A) -> None

-----------------------------------------------------------------

protocol IncrementalPlus[A] (Plus):
    __iadd__        : !(A) -> None
====>
"typeclass" (Plus[S]) => IncrementalPlus[S,A]:
    __iadd__        : !(S,A) -> None
====>
class IncrementalPlus[S,A] (Plus[S]):
    __iadd__        : !(S,A) -> None

-----------------------------------------------------------------

protocol IncrementalMinus[A] (Minus):
    __isub__        : !(A) -> None
====>
"typeclass" (Minus[S]) => IncrementalMinus[S,A]:
    __isub__        : !(S,A) -> None
====>
class IncrementalMinus[S,A] (Minus[S]):
    __isub__        : !(S,A) -> None

-----------------------------------------------------------------
    
protocol Foldable[A]:
    __fold__        : ((A,B)->B, B) -> B
====>
"typeclass" Foldable[S,A]:
    __fold__        : (S, (A,B)->B, B) -> B
====>
class Foldable[S,A]():
    __fold__        : (S, (A,B)->B, B) -> B

-----------------------------------------------------------------

### The collection hierarchy (from typing.py)

protocol Iterable[A]:
    __iter__        : () -> Iterator[A]
====>
"typeclass" Iterable[S,A]:
    __iter__        : (S) -> Iterator[A]
====>
class Iterable[S,A]():
    __iter__        : (S) -> Iterator[A]

-----------------------------------------------------------------

class Iterator[A] (Iterable[A]):                   # MUTUAL RECURSION BETWEEN TYPE AND PROTOCOL
    __next__        : !() -> A
    
    def __iter__(self): return self
====>
class Iterator[A]():
    __next__        : !() -> A
"instance" Iterable[Iterator[A],A]:
    def __iter__(self): return self
====>
class Iterator[A]():
    __next__        : !() -> A
class Iterable_Iterator (Iterable[Iterator[A],A]):
    def __iter__(cls,self): return self

-----------------------------------------------------------------

protocol Reversible[A] (Iterable[A]):
    __reversed__    : () -> Self
====>
"typeclass"  (Iterable[S,A]) => Reversible[S,A]:
    __reversed__    : (S) -> S
====>
class  Reversible[S,A] (Iterable[S,A]):
    __reversed__    : (S) -> S

-----------------------------------------------------------------

protocol Container[A]:
    __contains__    : (A) -> bool
====>
"typeclass" Container[S,A]:
    __contains__    : (S,A) -> bool
====>
class Container[S,A]():
    __contains__    : (S,A) -> bool

-----------------------------------------------------------------

protocol Sized:
    __len__         : () -> int
====>
"typeclass" Sized[S]:
    __len__         : (S) -> int
====>
class Sized[S]():
    __len__         : (S) -> int

-----------------------------------------------------------------

protocol Indexed[A,B]:
    __getitem__     : (A) -> B
====>
"typeclass" Indexed[S,A,B]:
    __getitem__     : (S,A) -> B
====>
class Indexed[S,A,B]():
    __getitem__     : (S,A) -> B

-----------------------------------------------------------------

protocol Sliceable:
    __getslice__    : (int?,int?,int?) -> Self
====>
"typeclass" Sliceable[S]:
    __getslice__    : (S,int?,int?,int?) -> S
====>
class Sliceable[S,A]():
    __getslice__    : (S,int?,int?,int?) -> S

-----------------------------------------------------------------

protocol Collection[A] (Container[A], Sized, Iterable[A]):
    __fromiter__    : (Iterable[A]) -> Self
====>
"typeclass" (Container[S,A], Sized[S], Iterable[S,A]) => Collection[S,A]:
    __fromiter__    : (Iterable[T,A]) => (T) -> S
====>
class Sized_Collection[S,A] (Sized[S]):
    _Collection     : @Collection[A]
class Iterable_Collection[S,A] (Iterable[S,A]):
    _Collection     : @Collection[A]
class Collection[S,A] (Container[S,A]):
    _Sized          : @Sized_Collection[S,A]
    _Iterable       : @Iterable_Collection[S,A]

    __fromiter__    : (@Iterable[A],T) -> S

-----------------------------------------------------------------

protocol Set[A] (Collection[A], Ord, Logical, Minus):
    isdisjoint      : (Set[A]) -> bool

    def __le__(a: Self, b: Self):
        if len(a) > len(b):
            return False
        for elem in a:
            if elem not in b:
                return False
        return True
    def __lt__(a: Self, b: Self):
        if len(a) >= len(b):
            return False
        for elem in a:
            if elem not in b:
                return False
        return True
    def __eq__(a: Self, b: Self):
        return len(a) == len(b) and a <= b
    def __or__(a: Self, b: Self):
        chain = [ e for s in [a,b] for e in s ]
        return fromiter(chain)
    def isdisjoint(self: Self, other: Set[A]):
        for value in b:
            if value in self:
                return False
        return True
====>
"typeclass" (Collection[S,A], Ord[S], Logical[S], Minus[S]) => Set[S,A]:
    isdisjoint      : (Set[T,A]) => (S,T) -> bool

    def __le__(a: S, b: S):
        if len(a) > len(b):
            return False
        for elem in a:
            if elem not in b:
                return False
        return True
    def __lt__(a: S, b: S):
        if len(a) >= len(b):
            return False
        for elem in a:
            if elem not in b:
                return False
        return True
    def __eq__(a: S, b: S):
        return len(a) == len(b) and a <= b
    def __or__(a: S, b: S):
        chain = [ e for s in [a,b] for e in s ]
        return fromiter(chain)
    def (Set[T,A]) => isdisjoint(self: S, other: T):
        for value in b:
            if value in self:
                return False
        return True
====>
class Sized_Set[S,A] (Sized_Collection[S]):
    _Set            : @Set[S,A]
class Iterable_Set[S,A] (Iterable_Collection[S,A]):
    _Set            : @Set[S,A]
class Ord_Set[S,A] (Ord[S]):
    _Set            : @Set[S,A]
    def __le__(cls, a:S, b:S):
        if Ord_int.__gt__(cls._Set._Sized.__len__(a), cls._Set._Sized.__len__(b)):
            return False
        for elem in cls._Set._Iterable.__iter__(a):
            if not cls._Set.__contains__(b,elem):
                return False
        return True
    def __lt__(cls, a:S, b:S):
        if Ord_int.__ge__(cls._Set._Sized.__len__(a), cls._Set._Sized.__len__(b)):
            return False
        for elem in cls._Set._Iterable.__iter__(a):
            if not cls._Set.__contains__(b,elem):
                return False
        return True
    def __eq__(cls, a: S, b: S):
        return Eq_int.__eq__(cls._Set._Sized.__len__(a), cls._Set._Sized.__len__(b)) and cls.__le__(a,b)
class Logical_Set[S,A] (Logical[S]):
    _Set            : @Set[S,A]
    def __or__(cls, a: S, b: S):
        chain = [ e for s in Iterable_list.__iter__([a,b]) for e in cls._Set._Iterable.__iter__(s) ]
        return cls.__fromiter__(Iterable_list,chain)
class Minus_Set[S,A] (Minus[S]):
    _Set            : @Set[S,A]
class Set[S,A] (Collection[S,A]):
    _Sized          : @Sized_Set[S,A]
    _Iterable       : @Iterable_Set[S,A]
    _Ord            : @Ord_Set[S,A]
    _Logical        : @Logical_Set[S,A]
    _Minus          : @Minus_Set[S,A]
    
    isdisjoint      : (@Set[T,A],S,T) -> bool

    def isdisjoint(cls:@Self, _q:@Set[T,A]), self:S, other:T):
        for value in _q._Iterable.__iter__(other):
            if cls.__contains__(value):
                return False
        return True

-----------------------------------------------------------------

extension Set[A (Hashable)] (Hashable):
    def __hash__(self):
        n = 12345
        for k in self:
            n += hash(k)
        return n
====>
"instance" (Hashable[A], Set[S,A]) => Hashable[S]:
    def __hash__(self):
        n = 12345
        for k in self:
            n += hash(k)
        return n
====>

def Hashable_Set[S,A] (_qual: @Hashable[A], _Set: @Set[S,A]) -> @Hashable[S]:
    
    class Hashable_Set[S,A] (Hashable[S]):    
        def __hash__(cls: class Self, self:S):
            n = 12345
            for k in _Set._Iterable.__iter__(self):
                n += _qual.__hash__(k)
            return n
    
    return Hashable_Set

-----------------------------------------------------------------

class frozenset[A (Hashable)] (Set[A], Hashable):
    _val        : frozendict[A,()]                          # HYPOTHETICAL!

    def __contains__(self, a):
        return a in self._val.keys()
    def __fromiter__(items: Iterable[A]):
        return frozenset(_val = { i:() for i in items })
    def __len__(self):
        return len(self._val)
    def __iter__(self):
        return iter(self._val.keys())
====>
"qualified struct" (Hashable[A]) => frozenset[A]:
    _val        : frozendict[A,()]
    
"instance" (Hashable[A]) => Set[frozenset[A],A]:
    def __contains__(self, a):
        return a in self._val.keys()
    def (Iterable[T,A]) => __fromiter__(items: T):
        return frozenset(_val = { i:() for i in items })

    def __len__(self):
        return len(self._val)
    def __iter__(self):
        return iter(self._val.keys())
"instance" (Hashable[A]) => Hashable[frozenset[A]]:
    def __hash__(self): ...
        n = 12345
        for i in self._val.keys():
            n += hash(i)
        return n
====>
class frozenset[A]():
    _qual           = Hashable
    _val            : frozendict[A,()]

def Set_frozenset[A](_qual: @Hashable[A]) -> @Set[frozenset[A],A]:
    
    class Sized_frozenset[A] (Sized_Set[frozenset[A],A]):
        _Collection     = Set_frozenset
        _Set            = Set_frozenset
        def __len__(cls,self):
            return len(self._val)
    class Iterable_frozenset[A] (Iterable_Set[frozenset[A],A]):
        _Collection     = Set_frozenset
        _Set            = Set_frozenset
        def __iter__(cls,self):
            return iter(self._val.keys())
    class Ord_frozenset[A] (Ord_Set[frozenset[A],A]):
        _Set            = Set_frozenset
    class Logical_frozenset[A] (Logical_Set[frozenset[A],A]):
        _Set            = Set_frozenset
    class Minus_frozenset[A] (Minus_Set[frozenset[A],A]):
        _Set            = Set_frozenset
    class Set_frozenset[A] (Set[frozenset[A],A]):
        _Sized          = Sized_frozenset
        _Iterable       = Iterable_frozenset
        _Ord            = Ord_frozenset
        _Logical        = Logical_frozenset
        _Minus          = Minus_frozenset
        def __contains__(cls,self,a):
            return Mapping_frozendict.__contains__(self._val,a)
        def __fromiter__(_qual: @Iterable[T,A], items: T):
            return frozenset(_val = { i:() for i in _qual.__iter__(items) })

    return Set_frozenset

####### Minus_frozenset[A] < Minus_Set[frozenset[A],A] < Minus[frozenset[A]]
## But assume frozensubset[A] < frozenset[A]
## and Minus_frozensubset[A] < Minus_frozenset[A]
## Can we inherit _sub_ from Minus_frozenset in Minus_frozensubset?
## Minus_frozenset._sub_ : (frozenset[A],frozenset[A])->frozenset[A] </ Minus_frozensubset._sub_ : (frozensubset[A],frozensubset[A])->frozensubset[A]
## Answer is NO!
## But had we instead defined
####### Minus_frozenset[A,S(frozenset[A])] < Minus_Set[S,A] < Minus[S]
## and
####### Minus_frozensubset[A,S(frosensubset[A])] < Minus_frozenset[A,S]
## Then
## Minus_frozenset._sub_ : [S(frozenset[A])]=>(S,S)->S < Minus_frozensubset._sub_ : [S(frozensubset[A])]=>(S,S)->S 
## I.e., Minus_frozenset._sub_ would be inheritable!
## But then the question is of course how to implement a generic Minus_frozenset._sub_ with type (S,S)->S that works for all S < frozenset...
## Conclusion: perhaps better stick to the non-inheritable version and ask all subclasses of frozenset for a reimplementation of _sub_

## Can we direct the translation on basis of what the type of Minus_frozenset._sub_ is?
## That is, if the inferred type is indeed [S(frozenset)]=>(S,S)->S, then the translation 
## Minus_frozenset[A,S(frozenset[A])] (Minus_Set[S,A]) is chosen and Minus_frozenset._sub_ is available to inherit
## Otherwise then translation defaults to Minus_frozenset[A] (Minus_Set[frozenset[A],A])
## Hmm, isn't this just translating the extension frozenset (Minus) on basis of the most general method types inferred?
## Yes, it is!

## Conclusion: how to translate extension declarations will be based on inferred types.
## And whether a method can be inherited or not will also be determined entirely by the type-checker.


def Hashable_frozenset[A](_qual: @Hashable[A]) -> @Hashable[frozenset[A]]:
    class Hashable_frozenset[A] (Hashable[frozenset[A]]):
        def __hash__(cls, self): ...
            n = 12345
            for k in Mapping_frozendict._Iterable.__iter__(self._val):
                n += _qual.__hash__(k)
            return n
    
    return Hashable_frozenset

---

Sized_frozenset_str = Sized_frozenset(Hashable_str)
Hashable_frozenset_str = Hashable_Set(Hashable_str, Set_frozenset_str)

---

x : frozenset[str]
x = frozenset(["apa","bepa"])
y = hash(x)
z = x.single()
====>
x : frozenset[str]
x = frozenset(["apa","bepa"])
y = __hash__(x)
z = x.single()
====>
x : frozenset[str]
x = frozenset(["apa","bepa"])
y = Hashable_frozenset_str.__hash__(x)
z = frozenset.single(x)

---

class coloredset[A (Hashable)] (frozenset[A]):
    color           : str
    
    def isblue(self):
        return self.color == "blue"
====>
"qualified struct" (Hashable[A]) => coloredset[A] (frozenset[A])
    color           : str
    
    def isblue(self):
        return self.color == "blue"
====>
class coloredset[A] (frozenset[A])
    color           : str

    def isblue      : () -> bool
    def isblue(self:Self):
        return self.color == "blue"

-----------------------------------------------------------------

protocol MutableIndexed[A,B] (Indexed[A,B]):
    __setitem__     : !(A,B) -> None
    __delitem__     : !(A) -> None
====>
"typeclass" (Indexed[S,A,B]) => MutableIndexed[S,A,B]:
    __setitem__     : !(S,A,B) -> None
    __delitem__     : !(S,A) -> None
====>
class MutableIndexed[S,A,B] (Indexed[S,A,B]):
    __setitem__     : !(S,A,B) -> None
    __delitem__     : !(S,A) -> None

-----------------------------------------------------------------

protocol MutableSet[A] (Set[A], IncrementalLogical[Set[A]], IncrementalMinus[Set[A]]):
    add             : !(A) -> None
    pop             : !() -> A
    clear           : !() -> None
    
    def clear(self: Self):
        try:
            while True:
                self.pop()
        except KeyError:
            pass

    def __ior__(self: Self, other: Set[A]):
        for value in other:
            self.add(value)
====>
"typeclass" (Set[S,A], IncrementalLogical[S,EXISTS[T,Set[T,A]], IncrementalMinus[S,EXISTS[T,Set[T,A]]) => MutableSet[S,A]:
    add             : !(A,A) -> None
    pop             : !(S) -> A
    clear           : !(S) -> None
    def clear(self: S):
        try:
            while True:
                self.pop()
        except KeyError:
            pass
    def __ior__(self: S, other: Set[A]):
        for value in other:
            self.add(value)
====>
class Sized_MutableSet[S,A] (Sized_Set[S,A]):
    _MutableSet         : MutableSet[S,A]
class Iterable_MutableSet[S,A] (Iterable_Set[S,A]):
    _MutableSet         : MutableSet[S,A]
class Ord_MutableSet[S,A] (Ord_Set[S,A]):
    _MutableSet         : MutableSet[S,A]
class Logical_MutableSet[S,A] (Logical_Set[S,A]):
    _MutableSet         : MutableSet[S,A]
class Minus_MutableSet[S,A] (Minus_Set[S,A]):
    _MutableSet         : MutableSet[S,A]
class IncrementalLogical_MutableSet[S,A] (IncrementalLogical[S,EXISTS[T,Set[T,A]]):
    _MutableSet         : MutableSet[S,A]
    def __ior__(cls,self: S, other: EXISTS[T,Set[T,A]):
        for value in other._protocol._Iterable.__iter__(other._element):
            cls._MutableSet.add(value)
class IncrementalMinus_MutableSet[S,A] (IncrementalMinus[S,EXISTS[T,Set[T,A]]):
    _MutableSet         : MutableSet[S,A]
class MutableSet[S,A] (Set[S,A]):
    _Sized              : Sized_MutableSet[S,A]
    _Iterable           : Iterable_MutableSet[S,A]
    _Ord                : Ord_MutableSet[S,A]
    _Logical            : Logical_MutableSet[S,A]
    _Minus              : Minus_MutableSet[S,A]
    _IncrementalLogical : IncrementalLogical_MutableSet[S,A]
    _IncrementalMinus   : IncrementalMinus_MutableSet[S,A]

    add             : !(S,A) -> None
    pop             : !(S) -> A
    def clear(wit, self):
        try:
            while True:
                wit.pop(self)
        except KeyError:
            pass


-----------------------------------------------------------------

# Type-based transformations:
# 
# * Every protocol method not mentioning 'Self' is classified as an "instance" method
# * A protocol method mentioning 'Self' is classified as a static method
# * Every protocol "instance" method gets an extra first argument of type 'Self'
# * Every protocol decl turns into a "typeclass" with an additional first type parameter 'Self'
# * Every protocol base "class" turns into a "typeclass" ancestor (with 'Self' inserted first)
# * In every type scheme: 
#   * Every type expression that is a protocol application is replaced by a new universally 
#     quantified variable and a corresponding protocol constraint in the schema constraint tuple
#   * Every type variable with an explicit protocol bound has its bound moved to the schema constraint tuple
#   * Nested types not occurring in type schemas of their own are treated as being part of the enclosing schema
# * In every class or class:
#   * Protocol bases turn into separate "instance" declarations for each protocol, with the declared struct/class
#     inserted as the first protocol type argument
#   * Every struct/class parameter with an explicit protocol bound has its bound moved into a constraint on the
#     struct/class constructor function
# * In every protocol extension:
#   * Every base protocol turns into an "instance" declaration for a fresh type variable, with the protocol constraint
#     on the new variable inserted as the first (last?) among the "instance" preconditions
# * 
# * Protocols with overlapping method names are disallowed (loosen this?)
# * Every selection expression mentioning a protocol "instance" method name generates the corresponding protocol constraint
# * Every variable expression mentioning a static protocol method name generates the corresponding protocol constraint
# * Constraint resolution and witness translation proceeds as in Haskell
    
# Superclass constraint (C) => means
# 
# * Additional function parameter                      (in a function/method type scheme)
# * Additional constructor parameter (and field)       (in a plain struct/class definition)
# * Additional constructor parameter (and field)       (in an "instance" (=struct) definition)
# * Additional "instance" existence requirement        (in a "typeclass" (=struct) definition)



-----------------------------------------------------------------

class set[A (Hashable)] (object, MutableSet[A]):
    def __len__(self): ...
    def __contains__(self, a): ...
    def __iter__(self): ...

    def __eq__(self, other): ...
    def __lt__(self, other): ...
    def __or__(self, other): ...

    def add(self, a): ...
    def update(self, other): ...
    def __ior__(self, other): ...
    def copy(self): ...
====>
"qualified class" (Hashable[A]) => set[A]:
    def __len__(self): ...
    def __contains__(self, a): ...
    def __iter__(self): ...

    def __eq__(self, other): ...
    def __lt__(self, other): ...
    def __or__(self, other): ...

    def add(self, a): ...
    def update(self, other): ...
    def __ior__(self, other): ...
    def copy(self): ...

"instance" (Hashable[A]) => MutableSet[set[A],A]:
    ...
====>
class set[A] (object):
    _qual           : @Hashable[A]
    ...

def MutableSet_set[A] (_qual: @Hashable[A]) -> @MutableSet[set[A],A]:
    class MutableSet_set[A] (MutableSet[A]):
        ...        
    return MutableSet_set

-----------------------------------------------------------------

### More collections from typing.py

protocol Mapping[A,B] (Collection[A], Indexed[A,B]):
    keys            : () -> Iterator[A]
    values          : () -> Iterator[B]
    items           : () -> Iterator[(A,B)]
====>
"typeclass" (Collection[S,A], Indexed[S,A,B]) => Mapping[S,A,B]:
    keys            : (S) -> Iterator[A]
    values          : (S) -> Iterator[B]
    items           : (S) -> Iterator[(A,B)]
====>
class Sized_Mapping[S,A,B] (Sized_Collection[S]):
    _Collection     = Mapping
    _Mapping        = Mapping
class Iterable_Mapping[S,A,B] (Iterable_Collection[S,A]):
    _Collection     = Mapping
    _Mapping        = Mapping
class Indexed_Mapping[S,A,B] (Indexed[S,A,B]):
    _Mapping        = Mapping
class Mapping[S,A,B] (Collection[S,A]):
    _Sized          = Sized_Mapping
    _Iterable       = Iterable_Mapping
    _Indexed        = Indexed_Mapping
    
    keys            : (S) -> Iterator[A]
    values          : (S) -> Iterator[B]
    items           : (S) -> Iterator[(A,B)]

-----------------------------------------------------------------

extension frozendict[A(Hashable),B] (Mapping[A,B]):
    def keys(self):
        ...
    ...
====>
"instance" (Hashable[A]) => Mapping[frozendict[A,B],A,B]:
    def keys(self):
        ...
    ...
====>
def Mapping_frozendict[A,B] (_qual: @Hashable[A]) -> @Mapping[frozendict[A,B],A,B]:
    
    class Sized_Mapping_frozendict[A,B] (Sized_Mapping[frozendict[A,B],A,B]):
        _Collection     = Mapping_frozendict
        _Mapping        = Mapping_frozendict
        ...
    class Iterable_Mapping_frozendict[A,B] (Iterable_Mapping[frozendict[A,B],A,B]):
        _Collection     = Mapping_frozendict
        _Mapping        = Mapping_frozendict
        ...
    class Indexed_Mapping_frozendict[A,B] (Indexed_Mapping[frozendict[A,B],A,B]):
        _Mapping        = Mapping_frozendict
        ...
    class Mapping_frozendict[A,B] (Mapping[frozendict[A,B],A,B]):
        _Sized          = Sized_Mapping_frozendict
        _Iterable       = Iterable_Mapping_frozendict
        _Indexed        = Indexed_Mapping_frozendict

        def keys(cls, self):
            ...
        ...
        
    return Mapping_frozendict

---

Mapping_frozendict_str = Mapping_frozendict(Hashable_str)

-----------------------------------------------------------------

extension IO (VarMonad[MutableVar])
extension ST[S] (VarMonad[MutableVar])
extension State[S] (StateMonad[S])
extension Env[E] (ReaderMonad[E])
extension NetCircuit (Hard[NetSignal])
extension SimCircuit (Hard[SimSignal])
extension ListSet[A(Eq)] (Collection[A])
extension TreeSet[A(Ord)] (Collection[A])
extension A (Iso[A])            .........
extension Foo (HasFoo[int])
extension Sequence[A(Eq)] (Eq)
extension tuple[A(Eq),B] (Foo)
extension Sequence[A(MyShow)] (MyShow)
extension Sequence[Char] (MyShow)
extension A(Monad) (Functor)   .........
extension StateT[S] (Monad)
extension T(MonadT)[M(StateMonad[S])] (StateMonad[S])
extension tuple[A(Eq),B(Eq)] (Eq)
extension [A(Eq),B(Eq)] => tuple[A,B] (Eq)
extension Tree[int] (Foo)
extension Tree[bool] (Foo)
extension F(Liftable)[A(Num)] (Num)
extension Ratio[A(Num)] (Num)
extension tuple[float,float] (Movable)
extension T[int,A] (D)
extension T[bool,A] (D)
extension tuple[A,A] (Foo)
extension [Sequence[Sequence[A]](C)] => Sequence[A] (C)  .........
extension T[M](Monad) (Foo) .........
extension [Sequence[Tree[A]](Eq)] => Tree[A(Eq)] (Eq) .........

extension [A,B(Eq)] => Mapping[A,B] (Eq)

-----------------------------------------------------------------

extension Mapping[A, B(Eq)] (Eq):
    def __eq__(a: Self, b: Self):
        if len(a) != len(b):
            return False
        for i in a:
            if i not in b:
                return False
            if a[i] /= b[i]:
                return False
        return True
====>
"instance" (Eq[B], Mapping[S,A,B]) => Eq[S]
    def __eq__(a: S, b: S):
        if len(a) != len(b):
            return False
        for i in a:
            if i not in b:
                return False
            if a[i] /= b[i]:
                return False
        return True
====>
def Eq_Mapping[S,A,B] (_qual: @Eq[B], _Mapping: @Mapping[S,A,B]) -> @Eq[S]:

    class Eq_Mapping[S,A,B] (Eq[S])
        def __eq__(cls, a: S, b: S):
            if Eq_int.__ne__(_Mapping._Sized.__len__(a), _Mapping._Sized.__len__(b))
                return False
            for k in _Mapping._Iterable.__iter__(a):
                if not _Mapping.__contains__(b,k):
                    return False
                if _qual.__ne__(_Mapping._Indexed.__getitem__(a,k), _Mapping._Indexed.__getitem__(b,k)):
                    return False
            return True
    
    return Eq_Mapping
    
---

def eqdict(a:frozendict[str,int], b:frozendict[str,int]) -> bool:
    return a == b
====>
def eqdict(a:frozendict[str,int], b:frozendict[str,int]) -> bool:
    return a == b
====>
def eqdict(a:frozendict[str,int], b:frozendict[str,int]) -> bool:
    Eq_Mapping_frozendict_str_int = Eq_Mapping(Eq_int, Mapping_frozendict(Hashable_str)
    return Eq_Mapping_frozendict_str_int.__eq__(a,b)

-----------------------------------------------------------------

protocol MutableMapping[A,B] (Mapping[A,B], MutableIndexed[A,B]):
    update          : !(Mapping[A,B]) -> None
====>
"typeclass" (Mapping[S,A,B], MutableIndexed[S,A,B]) => MutableMapping[S,A,B]:
    update          : (Mapping[T,A,B]) => !(S,T) -> None
====>
class Sized_MutableMapping[S,A,B] (Sized_Mapping[S]):
    _MutableMapping = MutableMapping
class Iterable_MutableMapping[S,A,B] (Iterable_Mapping[S,A]):
    _MutableMapping = MutableMapping
class Indexed_MutableMapping[S,A,B] (Indexed_Mapping[S,A,B]):
    _MutableMapping = MutableMapping
class MutableIndexed_MutableMapping[S,A,B] (MutableIndexed[S,A,B]):
    _MutableMapping = MutableMapping
class MutableMapping[S,A,B] (Mapping[S,A,B]):
    _Sized          = Sized_MutableMapping
    _Iterable       = Iterable_MutableMapping
    _Indexed        = Indexed_MutableMapping
    _MutableIndexed = MutableIndexed_MutableMapping
    
    update          : !(@Mapping[T,A,B],S,T) -> None

-----------------------------------------------------------------

protocol Sequence[A] (Collection[A], Indexed[int,A], Reversible[A], Plus):
    def __add__(self, other):       ...
    def __contains__(self, key):    ...
    def __iter__(self):             ...
    def __reversed__(self):         ...
====>
"typeclass" (Collection[S,A], Indexed[S,int,A], Reversible[S,A], Plus[S]) => Sequence[S,A]:
    def __add__(self, other):       ...
    def __contains__(self, key):    ...
    def __iter__(self):             ...
    def __reversed__(self):         ...
====>
class Sized_Sequence[S,A] (Sized_Collection[S]):
    _Collection     = Sequence
    _Sequence       = Sequence
    def __contains__(cls, self, key): ...
class Iterable_Sequence[S,A] (Iterable_Collection[S,A]):
    _Collection     = Sequence
    _Sequence       = Sequence
    def __iter__(cls, self): ...
class Indexed_Sequence[S,A] (Indexed[S,int,A]):
    _Sequence       = Sequence
class Reversible_Sequence[S,A] (Reversible[S,A]):
    _Sequence       = Sequence
    def __reversed__(cls, self): ...
class Plus_Sequence[S,A] (Plus[S]):
    _Sequence       = Sequence
    def __add__(cls, self, other): ...
class Sequence[S,A] (Collection[S,A]):
    _Sized          = Sized_Sequence
    _Iterable       = Iterable_Sequence
    _Indexed        = Indexed_Sequence
    _Reversible     = Reversible_Sequence
    _Plus           = Plus_Sequence

-----------------------------------------------------------------

extension Sequence[A (Eq)] (Eq):
    def __eq__(a: Self, b: Self):
        if len(a) != len(b):
            return False
        for i in range(0,len(a)):
            if a[i] != b[i]:
                return False
        return True
====>
"instance" (Eq[A], Sequence[S,A]) => Eq[S]:
    def __eq__(a: S, b: S):
        if len(a) != len(b):
            return False
        for i in range(0,len(a)):
            if a[i] != b[i]:
                return False
        return True
====>
def Eq_Sequence[S,A] (_qual: @Eq[A], _Sequence: @Sequence[S,A]) -> Eq[S]:

    class Eq_Sequence[S,A] (Eq[S]):
        def __eq__(cls, a: S, b: S):                # OLD METHOD, SIGNATURE IS FIXED, CAN'T TAKE _qual AS A DIRECT ARGUMENT
            if Eq_int.__ne__(cls._Sequence._Sized.__len__(a), cls._Sequence._Sized.__len__(b)):
                return False
            for i in Iterable_range.__iter__(range(0,cls._Sequence._Sized.__len__(a))):
                if cls._qual.__ne__(cls._Sequence._Indexed.__getitem__(a,i), cls._Sequence._Indexed.__getitem__(b,i)):
                    return False
            return True

    return Eq_Sequence

-----------------------------------------------------------------

extension Sequence[A (Eq)]:                                             # EXTENDED PROTOCOL WITH NEW METHODS AND TIGHTER PRE-CONDITION
    index           : (A) -> int?       
    count           : (A) -> int
    
    def index(self, val):
        for i,x in enumerate(self):
            if x == val:
                return i
        return None
    def count(self, val):
        c = 0
        for x in self:
            if x == val:
                c += 1
        return c
f : [A(Eq),S(Sequence[A])] => (S,A) -> int                              # INFERRED
def f(s,a):
    return s.count(a)
====>
"typeclass" (Eq[A], Sequence[S,A]) => Sequence_EXT[S,A]:
    index           : (S,A) -> int?
    count           : (S,A) -> int
    def index(self, val):
        for i,x in enumerate(self):
            if x == val:
                return i
        return None
    def count(self, val):
        c = 0
        for x in self:
            if x == val:
                c += 1
        return c
f : (Eq[A],Sequence[S,A], Sequence_EXT[S,A]) => (S,A) -> int            # INFERRED
f : (Eq[A],Sequence[S,A]) => (S,A) -> int                               # CONTEXT-REDUCED (ALWAYS REDUCE AN EXTENDED PROTOCOL)
def f(s,a):
    return s.count(a)
====>
class Sequence_EXT[S,A]():
    _Eq             : @Eq[A]
    _Sequence       : @Sequence[S,A]
    index           : (S,A) -> int?
    count           : (S,A) -> int

    def index(cls, self, val):
        for i,x in enumerate(cls._Sequence._Iterable.__iter__(self)):
            if cls._Eq.__eq__(x,val):
                return i
        return None
    def count(cls, self, val):
        c = 0
        for x in cls._Sequence._Iterable.__iter__(self):
            if cls._Eq.__eq__(x,val):
                c += 1
        return c

def f(_Sequence_EXT:@Sequence_EXT[S,A], s:S, a:A):
    return _Sequence_EXT.count(s,a)

def f(_Eq:@Eq[A], _Sequence:@Sequence[S,A], s:S, a:A):
    class Sequence_EXT1[S,A] (Sequence_EXT[S,A]):
        _Eq       = _Eq
        _Sequence = _Sequence
    return _Sequence_EXT1.count(s,a)

### OR ####

class Sequence_EXT[S,A]():
    index           : (@Eq[A], @Sequence[S,A], S, A) -> int?            # NEW METHOD, SIGNATURE CAN BE ADAPTED
    count           : (@Eq[A], @Sequence[S,A], S, A) -> int             # NEW METHOD, SIGNATURE CAN BE ADAPTED

    def index(cls, _Eq: @Eq[A], _Sequence:@Sequence[S,A], self:S, val:A) -> int?:
        for i,x in enumerate(_Sequence._Iterable.__iter__(self)):
            if _Eq.__eq__(x,val):
                return i
        return None
    def count(cls, _Eq: @Eq[A], _Sequence:@Sequence[S,A], self:S, val:A) -> int:
        c = 0
        for x in _Sequence._Iterable.__iter__(self):
            if _Eq.__eq__(x,val):
                c += 1
        return c

def f(_Eq:@Eq[A], _Sequence:@Sequence[S,A], s:S, a:A):
    return Sequence_EXT.count(_Eq,_Sequence,s,a)

### OR ####

class Sequence_EXT[S,A]():
    index           : (@Eq[A], @Sequence[S,A], S, A) -> int?
    count           : (@Eq[A], @Sequence[S,A], S, A) -> int

def Sequence_EXT_Eq_Sequence(_Eq: @Eq[A], _Sequence:@Sequence[S,A]):
    class Sequence_EXT[S,A]():
        def index(cls, self:S, val:A) -> int?:
            for i,x in enumerate(_Sequence._Iterable.__iter__(self)):
                if _Eq.__eq__(x,val):
                    return i
            return None
        def count(cls, self:S, val:A) -> int:
            c = 0
            for x in _Sequence._Iterable.__iter__(self):
                if _Eq.__eq__(x,val):
                    c += 1
            return c
    return Sequence_EXT_Eq_Sequence

def f(_Eq:@Eq[A], _Sequence:@Sequence[S,A], s:S, a:A):
    Sequence_EXT = Sequence_EXT_Eq_Sequence(_Eq,_Sequence)
    return Sequence_EXT.count(s,a)

-----------------------------------------------------------------

protocol MutableSequence[A] (Sequence[A], MutableIndexed[int,A], IncrementalPlus[Sequence[A]]):
    append          : !(A) -> None
    __iadd__        : !(Sequence[A]) -> None
    
    def append(self, other):
        ...
    def __iadd__(self, other):
        self.append(other)
====>
"typeclass" (Sequence[S,A], MutableIndexed[S,int,A], IncrementalPlus[S,Sequence[T,A]]) => MutableSequence[S,A]:
    append          : !(S,A) -> None
    __iadd__        : !(S,    Sequence[T,A]) -> None

    def append(self, other):
        ...
    def __iadd__(self, other):
        for v in other:
            self.append(v)
====>
class Sized_MutableSequence[S,A] (Sized_Sequence[S]):
    _Collection         = MutableSequence
    _Sequence           = MutableSequence
    _MutableSequence    = MutableSequence
class Iterable_MutableSequence[S,A] (Iterable_Sequence[S,A]):
    _Collection         = MutableSequence
    _Sequence           = MutableSequence
    _MutableSequence    = MutableSequence
class Indexed_MutableSequence[S,A] (Indexed_Sequence[S,int,A]):
    _Sequence           = MutableSequence
    _MutableSequence    = MutableSequence
class Reversible_MutableSequence[S,A] (Reversible_Sequence[S,A]):
    _Sequence           = MutableSequence
    _MutableSequence    = MutableSequence
class Plus_MutableSequence[S,A] (Plus[S]):
    _Sequence           = MutableSequence
    _MutableSequence    = MutableSequence
class MutableIndexed_MutableSequence[S,A] (MutableIndexed[S,int,A]):
    _MutableSequence    = MutableSequence
class IncrementalPlus_MutableSequence[S,A] (IncrementalPlus[S,    Sequence[T,A]    ]):  #####################
    _MutableSequence    = MutableSequence

    __iadd__            : !(S,    Sequence[T,A]    ) -> None                             #####################

    def __iadd__(self, other):
        other_val : TTTTT = some_other.val
        other_w : Sequence[TTTTT,A] = some_other.proto
        for v in other_w._Iterable.__iter__(other_val):
            self.append(v)

class MutableSequence[S,A] (Sequence[S,A]):
    _Sized              = Sized_MutableSequence
    _Iterable           = Iterable_MutableSequence
    _Indexed            = Indexed_MutableSequence
    _Reversible         = Reversible_MutableSequence
    _Plus               = Plus_MutableSequence
    _MutableIndexed     = MutableIndexed_MutableSequence
    _IncrementalPlus    = IncrementalPlus_MutableSequence[S,A])

    append              : !(S,A) -> None

    def append(cls, self, val):
        ...

-----------------------------------------------------------------

protocol Apa:
    def apa1(self):
        return 1
    def apa2(self):
        return 2
protocol Bepa (Apa):
    def apa1(self):
        return 3
    def bepa(self):
        return 30 + self.apa2()
protocol Cepa (Apa):
    def apa2(self):
        return 4
    def cepa(self):
        return 40 + self.apa1()
protocol Depa (Cepa, Bepa):             # mro: Depa, Cepa, Bepa, Apa
    def depa(self):
        return (self.apa1(), self.apa2(), self.bepa(), self.cepa())
====>
class Apa[S] ():
    def apa1(wit,self):
        return 1
    def apa2(wit,self):
        return 2

class Bepa[S] (Apa[S]):
    def apa1(wit,self):
        return 3
    def bepa(wit,self):
        return 30 + wit.apa2(self)

class Cepa[S] (Apa[S]):
    def apa2(wit,self):
        return 4
    def cepa(wit,self):
        return 40 + wit.apa1(self)

class Bepa_Depa[S] (Bepa[S]):
    _Depa       : Depa[S]
    def apa2(wit,self):
        return wit._Depa.apa2(self)                     # DIAMOND PROBLEM RESOLUTION

class Depa[S] (Cepa[S]):
    _Bepa       : Bepa[S]
    def __init__(wit):
        wit._Bepa = Bepa_Depa(wit)
    def apa1(wit,self):                                 # DIAMOND PROBLEM RESOLUTION
        return wit._Bepa.apa1(self)
    def depa(wit,self):
        return (wit.apa1(self), wit.apa2(self), wit._Bepa.bepa(self), wit.cepa(self))

---------------------

extension int (Depa):
    pass
====>
"instance" Depa[int]:
    pass
====>
wit  : Depa[int] = Depa()
witB : Bepa[int] = wit._Bepa

7.depa() ====> 
wit.depa(7) ====> 
Depa.depa(wit,7) ====> 
(wit.apa1(7), wit.apa2(7), wit._Bepa.bepa(7), wit.cepa(7)) ====>
(Bepa.apa1(wit,7), Cepa.apa2(wit,7), Bepa.bepa(witB,7), Cepa.cepa(wit,7)) ====>
(3, 4, 30 + witB.apa2(7), 40 + wit.apa1(7)) ====>
(3, 4, 30 + witB._Depa.apa2(7), 40 + wit._Bepa.apa1(7)) ====>
(3, 4, 30 + wit.apa2(7), 40 + witB.apa1(7)) ====>
(3, 4, 30 + Cepa.apa2(wit,7), 40 + Bepa.apa1(witB,7)) ====>
(3, 4, 30 + 4, 40 + 3) ====>
(3, 4, 34, 43)


-----------------------------------------------------------------

protocol Apa:
    def apa1(self):
        return 1
    def apa2(self):
        return 2
protocol Bepa (Apa):
    def apa1(self):
        return 3
    def bepa(self):
        return 30 + self.apa2()
protocol Cepa (Apa):
    def apa2(self):
        return 4
    def cepa(self):
        return 40 + self.apa1()
protocol Depa (Cepa, Bepa):
    def depa(self):
        return (self.apa1(), self.apa2(), self.bepa(), self.cepa())
protocol Xtra (Apa):
    def apa1(self):
        return 5
    def apa2(self):
        return 6
protocol Epa1 (Depa,Xtra,Bepa):      # mro: Epa1,Depa,Cepa,Xtra,Bepa,Apa
    pass
protocol Epa2 (Depa,Xtra,Cepa):      # mro: Epa2,Depa,Xtra,Cepa,Bepa,Apa
    pass
====>
class Apa[S] ():                    # apa1, apa2
    def apa1(wit,self):
        return 1
    def apa2(wit,self):
        return 2

class Bepa[S] (Apa[S]):             # apa1, apa2, bepa
    def apa1(wit,self):
        return 3
    # apa2 = Apa.apa2
    def bepa(wit,self):
        return 30 + wit.apa2(self)

class Cepa[S] (Apa[S]):             # apa1, apa2, cepa
    # apa1 = Apa.apa1
    def apa2(wit,self):
        return 4
    def cepa(wit,self):
        return 40 + wit.apa1(self)

class Bepa_Depa[S] (Bepa[S]):       # apa1, apa2, bepa
    _Depa       : Depa[S]
    # apa1 = Bepa.apa1
    def apa2(wit,self):
        return wit._Depa.apa2(self)                     # DIAMOND PROBLEM RESOLUTION
    # bepa = Bepa.bepa

class Depa[S] (Cepa[S]):            # apa1, apa2, cepa, depa, bepa
    _Bepa       : Bepa[S]
    def __init__(wit):
        wit._Bepa = Bepa_Depa(wit)
    def apa1(wit,self):                                 # DIAMOND PROBLEM RESOLUTION
        return wit._Bepa.apa1(self)
    # apa2 = Cepa.apa2
    # cepa = Cepa.cepa
    def depa(wit,self):
        return (wit.apa1(self), wit.apa2(self), wit.bepa(self), wit.cepa(self))
    def bepa(wit,self):
        return wit._Bepa.bepa(self)
        
# mro:      Depa        Cepa        Bepa        Apa
#           -           -           apa1        (apa1)
#           -           apa2        *-          (apa2)
#           -           cepa
#           depa
#           -*                      bepa

----

class Xtra[S] (Apa[S]):             # apa1, apa2
    def apa1(wit,self):
        return 5
    def apa2(wit,self):
        return 6

----

class Xtra_Epa1[S] (Xtra[S]):       # apa1, apa2
    _Exp1       : Epa1[S]
    # apa1 = Xtra.apa1
    def apa2(wit,self):
        return wit._Exp1.apa1(self)

class Bepa_Epa1[S] (Bepa[S]):       # apa1, apa2, bepa
    _Epa1       : Epa1[S]
    def apa1(wit,self):
        return wit._Epa1.apa1(self)
    def apa2(wit,self):
        return wit._Epa1.apa2(self)
    # bepa = Bepa.bepa
    
class Epa1[S] (Depa[S]):            # apa1, apa2, cepa, depa, bepa
    _Xtra       : Xtra[S]
    def __init__(wit):
        wit._Bepa = Bepa_Epa1(wit)
        wit._Xtra = Xtra_Epa1(wit)
    def apa1(wit,self):
        return wit._Xtra.apa1(self)
    # apa2 = Cepa.apa2
    # cepa = Depa.cepa
    # depa = Depa.depa
    # bepa = Depa.bepa
    
# mro:      Epa1      Depa      Cepa        Xtra        Bepa        Apa
#           -*        -         -           apa1        *-          (apa1)
#           -         -         apa2        *-          *-          (apa2)
#           -         -         cepa
#           -         depa
#           -         -*                                bepa

----

class Xtra_Epa2[S] (Xtra[S]):       # apa1, apa2
    _Exp1       : Epa1[S]
    # apa1 = Xtra.apa1
    # apa2 = Xtra.apa2

class Bepa_Epa2[S] (Bepa[S]):       # apa1, apa2, bepa
    _Epa1       : Epa1[S]
    def apa1(wit,self):
        return wit._Epa2.apa1(self)
    def apa2(wit,self):
        return wit._Epa2.apa2(self)
    # bepa = Bepa.bepa
    
class Epa2[S] (Depa[S]):            # apa1, apa2, cepa, depa, bepa
    _Xtra       : Xtra[S]
    def __init__(wit):
        wit._Bepa = Bepa_Epa2(wit)
        wit._Xtra = Xtra_Epa2(wit)
    def apa1(wit,self):
        return wit._Xtra.apa1(self)
    def apa2(wit,self):
        return wit._Xtra.apa2(self)
    # cepa = Depa.cepa
    # depa = Depa.depa
    # bepa = Depa.bepa
    
# mro:      Epa2      Depa      Xtra        Cepa        Bepa        Apa
#           -*        -         apa1        -           *-          (apa1)
#           -*        -         apa2        -           *-          (apa2)
#           -         -                     cepa
#           -         depa
#           -         -*                                bepa

---------------------

extension int (Depa):
    pass
====>
"instance" Depa[int]:
    pass
====>
wit  : Depa[int] = Depa()
witB : Bepa[int] = wit._Bepa

7.depa() ====> 
wit.depa(7) ====> 
Depa.depa(wit,7) ====> 
(wit.apa1(7), wit.apa2(7), wit._Bepa.bepa(7), wit.cepa(7)) ====>
(Bepa.apa1(wit,7), Cepa.apa2(wit,7), Bepa.bepa(witB,7), Cepa.cepa(wit,7)) ====>
(3, 4, 30 + witB.apa2(7), 40 + wit.apa1(7)) ====>
(3, 4, 30 + witB._Depa.apa2(7), 40 + wit._Bepa.apa1(7)) ====>
(3, 4, 30 + wit.apa2(7), 40 + witB.apa1(7)) ====>
(3, 4, 30 + Cepa.apa2(wit,7), 40 + Bepa.apa1(witB,7)) ====>
(3, 4, 30 + 4, 40 + 3) ====>
(3, 4, 34, 43)

-------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------

protocol Apa:
    def apa1(self):
        return 1
    def apa2(self):
        return 2

protocol Bepa (Apa):
    def apa1(self):
        return 10
    def bepa(self):
        return self.apa2()

protocol Cepa (Apa):
    def apa2(self):
        return 20
    def cepa(self):
        return self.apa1()

---

protocol Depa (Cepa,Bepa):
    def depa(self):
        return (self.cepa(), self.bepa())

extension int (Depa):                       # Extension by multi inheritance protocol
    def ipa(self):
        return depa(self)

---

extension str (Cepa,Bepa):                  # Simultaneous multi extension
    def epa(self):
        return (self.cepa(), self.bepa())

---

extension str (Bepa):                       # First extension
    pass

extension str (Cepa):                       # Second extension. Hmm... should this really affect the str (Bepa) extension behavior? Yes, on the
    def fepa(self):                         #                   grounds that it introduces a new behavior for str.apa2, on which str.bepa depends.
        return (self.cepa(), self.bepa())

---

extension list[A] (Bepa):                   # First extension
    pass

extension list[A] (Cepa):
    def fepa(self):                         # Second extension
        return (self.cepa(), self.bepa())
    

# Witness translation goal: keep witnesses selection for Self and its type parameters open-ended in the OO way!
# Achieve this via the "self" parameter of the translated protocol methods, here denoted "w" to distinguish it from the original "self"

====================================================>           # Regular translation, avoiding class inheritance in translation of multiple base protocols

class Apa[S] ():
    def apa1(w, self):
        return 1
    def apa2(w, self):
        return 2

        
class Bepa[S] ():

    class Apa_wrapped[S] (Apa[S]):
        _main   : Bepa[S]
        def apa1(w, self):
            return w._main.apa1(self)           # Overriding apa1 (= redirection to Bepa, in case of Apa sibling use or Bepa promotion to Apa)
        # apa2 = Apa.apa1                       # Inheriting apa2

    _Apa    : Apa[S]
    def __init__(w):
        w._Apa = Apa_wrapped(_main = w)
        
    def apa1(w, self):                      # Overriding apa1
        return 10
    def apa2(w, self):                      # "Inheriting" apa2 (= delegation to Apa, in case of either Bepa sibling use or official Bepa call)
        return w._Apa.apa2(self)
    def bepa(w, self):                      # Adding bepa
        return w.apa2(self)

            
class Cepa[S] ():

    class Apa_wrapped[S] (Apa[S]):
        _main   : Cepa[S]
        # apa1 = Apa.apa1                       # Inheriting apa1
        def apa2(w, self):
            return w._main.apa2(self)           # Overriding apa2 (= redirection to Cepa, in case of Apa sibling use or Cepa promotion to Apa)

    _Apa    : Apa[S]
    def __init__(w):
        w._Apa = Apa_wrapped(_main = w)

    def apa1(w, self):                      # "Inheriting" apa1 (= delegation to Apa, in case of Cepa sibling use or official Cepa call)
        return w._Apa.apa1(self)
    def apa2(w, self):                      # Overriding apa2
        return 20
    def cepa(w, self):                      # Adding cepa
        return w.apa1(self)

--- extension int (Depa)

class Depa[S] ():
    
    class Bepa_wrapped[S] (Bepa[S]):
        _main   : Depa[S]
        # apa1 = Bepa.apa1                      # Inheriting apa1
        def apa2(w, self):                      # Overriding apa2 (= redirection to Depa, in case of Bepa sibling use or Depa promotion to Bepa)
            return w._main.apa2(self)
        # bepa = Bepa.bepa                      # Inheriting bepa
        
    class Cepa_wrapped[S] (Cepa[S]):
        _main   : Depa[S]
        def apa1(w, self):                      # Overriding apa1 (= redirection to Depa, in case of Cepa sibling use or Depa promotion to Cepa)
            return w._main.apa1(self)
        # apa2 = Cepa.apa2                      # Inheriting apa2
        # cepa = Cepa.cepa                      # Inheriting cepa
    
    _Bepa   : Bepa[S]
    _Cepa   : Cepa[S]
    def __init__(w):
        w._Bepa = Bepa_wrapped(_main = w)
        w._Cepa = Cepa_wrapped(_main = w)

    def apa1(w, self):                      # "Inheriting" apa1 (= delegation to Bepa, in case of Depa sibling use or official Depa call)
        return w._Bepa.apa1(self)
    def bepa(w, self):                      # "Inheriting" bepa (= delegation to Bepa, in case of Depa sibling use or official Depa call)
        return w._Bepa.bepa(self)
    def apa2(w, self):                      # "Inheriting" apa2 (= delegation to Cepa, in case of Depa sibling use or official Depa call)
        return w._Cepa.apa2(self)
    def cepa(w, self):                      # "Inheriting" cepa (= delegation to Cepa, in case of Depa sibling use or official Depa call)
        return w._Cepa.bepa(self)
    def depa(w, self):                      # Adding depa
        return w.cepa(self) + w.bepa(self)
    
class Depa_int (Depa[int]):                 # Extension by multi inheritance protocol
    def __init__(w):
        Depa.__init__(w)
    def ipa(w, self):
        return w.depa(self)

--- extension str (Cepa,Bepa)

class Cepa_Bepa_str ():                     # Simultaneous multi extension

    class Bepa_wrapped (Bepa[str]):
        _main   : Cepa_Bepa_str
        # apa1 = Bepa.apa1                      # Inheriting apa1
        def apa2(w, self):                      # Overriding apa2 (= redirection to Cepa_Bepa_str, in case of Bepa sibling use or Cepa_Bepa_str promotion to Bepa)
            return w._main.apa2(self)
        # bepa = Bepa.bepa                      # Inheriting bepa
        
    class Cepa_wrapped (Cepa[str]):
        _main   : Cepa_Bepa_str
        def apa1(w, self):                      # Overriding apa1 (= redirection to Cepa_Bepa_str, in case of Cepa sibling use or Cepa_Bepa_str promotion to Cepa)
            return w._main.apa1(self)
        # apa2 = Cepa.apa2                      # Inheriting apa2
        # cepa = Cepa.cepa                      # Inheriting cepa
    
    _Bepa   : Bepa[str]
    _Cepa   : Cepa[str]
    def __init__(w):
        w._Bepa = Bepa_wrapped(_main = w)
        w._Cepa = Cepa_wrapped(_main = w)

    def apa1(w, self):                      # "Inheriting" apa1 (= delegation to Bepa, in case of Cepa_Bepa_str sibling use or official Cepa_Bepa_str call)
        return w._Bepa.apa1(self)
    def bepa(w, self):                      # "Inheriting" bepa (= delegation to Bepa, in case of Cepa_Bepa_str sibling use or official Cepa_Bepa_str call)
        return w._Bepa.bepa(self)
    def apa2(w, self):                      # "Inheriting" apa2 (= delegation to Cepa, in case of Cepa_Bepa_str sibling use or official Cepa_Bepa_str call)
        return w._Cepa.apa2(self)
    def cepa(w, self):                      # "Inheriting" cepa (= delegation to Cepa, in case of Cepa_Bepa_str sibling use or official Cepa_Bepa_str call)
        return w._Cepa.bepa(self)
    def depa(w, self):                      # Adding depa
        return w.cepa(self) + w.bepa(self)

    def epa(w, self):
        return w.cepa(self) + w.bepa(self)

--- extension str (Bepa); extension str (Cepa)

class Bepa_str ():                          # First extension

    class Bepa_wrapped (Bepa[str]):
        _main   : Bepa_str
        # apa1 = Bepa.apa1                      # Inheriting apa1
        # apa2 = Bepa.apa2                      # Inheriting apa2
        # bepa = Bepa.bepa                      # Inheriting bepa
        
    _Bepa   : Bepa[str]                     # NOTE: real str(Bepa) witness!
    def __init__(w):
        w._Bepa = Bepa_wrapped(_main = w)

    def apa1(w, self):                      # "Inheriting" apa1 (= delegation to Bepa, in case of Bepa_str sibling use or official Bepa_str call)
        return w._Bepa.apa1(self)
    def apa2(w, self):                      # "Inheriting" apa2 (= delegation to Bepa, in case of Bepa_str sibling use or official Bepa_str call)
        return w._Bepa.apa2(self)
    def bepa(w, self):                      # "Inheriting" bepa (= delegation to Bepa, in case of Bepa_str sibling use or official Bepa_str call)
        return w._Bepa.bepa(self)

class Cepa_Bepa_str (Bepa_str):             # Second extension

    class Cepa_wrapped (Cepa[str]):
        _main   : Cepa_Bepa_str
        def apa1(w, self):                      # Overriding apa1 (= redirection to Cepa_Bepa_str, in case of Cepa sibling use or Cepa_Bepa_str promotion to Cepa)
            return w._main.apa1(self)
        # apa2 = Cepa.apa2                      # Inheriting apa2
        # cepa = Cepa.cepa                      # Inheriting cepa
    
    _Cepa   : Cepa[str]                     # NOTE: real str(Cepa) witness!
    def __init__(w):
        Bepa_str.__init__(w)
        w._Cepa = Cepa_wrapped(_main = w)

    # apa1 = Bepa_str.apa1                  # Inheriting apa1
    def apa2(w, self):                      # "Inheriting" apa2 (= delegation to Cepa, in case of Cepa_Bepa_str sibling use or official Cepa_Bepa_str call)
        return w._Cepa.apa2(self)
    # bepa = Bepa_str.bepa                  # Inheriting bepa
    def cepa(w, self):                      # "Inheriting" cepa (= delegation to Cepa, in case of Cepa_Bepa_str sibling use or official Cepa_Bepa_str call)
        return w._Cepa.bepa(self)
    def fepa(w, self):                      # Adding depa
        return w.cepa(self) + w.bepa(self)

--- extension list[A] (Bepa); extension list[A] (Cepa)

class Bepa_list[A] ():                      # First extension

    class Bepa_wrapped[A] (Bepa[list[A]]):
        _main   : Bepa_list
        # apa1 = Bepa.apa1                      # Inheriting apa1
        # apa2 = Bepa.apa2                      # Inheriting apa2
        # bepa = Bepa.bepa                      # Inheriting bepa
        
    _Bepa   : Bepa[list[A]]                 # NOTE: real list[A](Bepa) witness!
    def __init__(w):
        w._Bepa = Bepa_wrapped(_main = w)

    def apa1(w, self):                      # "Inheriting" apa1 (= delegation to Bepa, in case of Bepa_list sibling use or official Bepa_list call)
        return w._Bepa.apa1(self)
    def apa2(w, self):                      # "Inheriting" apa2 (= delegation to Bepa, in case of Bepa_list sibling use or official Bepa_list call)
        return w._Bepa.apa2(self)
    def bepa(w, self):                      # "Inheriting" bepa (= delegation to Bepa, in case of Bepa_list sibling use or official Bepa_list call)
        return w._Bepa.bepa(self)

class Cepa_Bepa_list[A] (Bepa_list[A]):     # Second extension

    class Cepa_wrapped[A] (Cepa[list[A]]):
        _main   : Cepa_Bepa_list[A]
        def apa1(w, self):                      # Overriding apa1 (= redirection to Cepa_Bepa_list, in case of Cepa sibling use or Cepa_Bepa_list prom to Cepa)
            return w._main.apa1(self)
        # apa2 = Cepa.apa2                      # Inheriting apa2
        # cepa = Cepa.cepa                      # Inheriting cepa
    
    _Cepa   : Cepa[list[A]]                 # NOTE: real str(Cepa) witness!
    def __init__(w):
        Bepa_list.__init__(w)
        w._Cepa = Cepa_wrapped(_main = w)

    # apa1 = Bepa_list.apa1                 # Inheriting apa1
    def apa2(w, self):                      # "Inheriting" apa2 (= delegation to Cepa, in case of Cepa_Bepa_list sibling use or official Cepa_Bepa_list call)
        return w._Cepa.apa2(self)
    # bepa = Bepa_list.bepa                 # Inheriting bepa
    def cepa(w, self):                      # "Inheriting" cepa (= delegation to Cepa, in case of Cepa_Bepa_list sibling use or official Cepa_Bepa_list call)
        return w._Cepa.bepa(self)
    def fepa(w, self):                      # Adding depa
        return w.cepa(self) + w.bepa(self)

--- extension set[A(Eq)] (Bepa); extension set[A(Ord)] (Cepa)

class Bepa_set[A] ():                      # First extension

    class Bepa_wrapped[A] (Bepa[set[A]]):
        _main   : Bepa_set[A]
        _Eq_A   : Eq[A]
        # apa1 = Bepa.apa1                      # Inheriting apa1
        # apa2 = Bepa.apa2                      # Inheriting apa2
        # bepa = Bepa.bepa                      # Inheriting bepa
        
    _Bepa   : Bepa[set[A]]                 # NOTE: real set[A](Bepa) witness!
    def __init__(w, _Eq_A):
        w._Bepa = Bepa_wrapped(_main = w, _Eq_A = _Eq_A)

    def apa1(w, self):                      # "Inheriting" apa1 (= delegation to Bepa, in case of Bepa_set sibling use or official Bepa_set call)
        return w._Bepa.apa1(self)
    def apa2(w, self):                      # "Inheriting" apa2 (= delegation to Bepa, in case of Bepa_set sibling use or official Bepa_set call)
        return w._Bepa.apa2(self)
    def bepa(w, self):                      # "Inheriting" bepa (= delegation to Bepa, in case of Bepa_set sibling use or official Bepa_set call)
        return w._Bepa.bepa(self)

class Cepa_Bepa_set[A] (Bepa_set[A]):       # Second extension

    class Cepa_wrapped[A] (Cepa[set[A]]):
        _main   : Cepa_Bepa_set[A]
        _Ord_A  : Ord[A]
        def apa1(w, self):                      # Overriding apa1 (= redirection to Cepa_Bepa_set, in case of Cepa sibling use or Cepa_Bepa_set prom to Cepa)
            return w._main.apa1(self)
        # apa2 = Cepa.apa2                      # Inheriting apa2
        # cepa = Cepa.cepa                      # Inheriting cepa
    
    _Cepa   : Cepa[set[A]]                  # NOTE: real str(Cepa) witness!
    def __init__(w, _Ord_A):
        Bepa_set.__init__(w, _Eq_A = _Ord_A)
        w._Cepa = Cepa_wrapped(_main = w, _Ord_A = _Ord_A)

    # apa1 = Bepa_set.apa1                  # Inheriting apa1
    def apa2(w, self):                      # "Inheriting" apa2 (= delegation to Cepa, in case of Cepa_Bepa_set sibling use or official Cepa_Bepa_set call)
        return w._Cepa.apa2(self)
    # bepa = Bepa_set.bepa                  # Inheriting bepa
    def cepa(w, self):                      # "Inheriting" cepa (= delegation to Cepa, in case of Cepa_Bepa_set sibling use or official Cepa_Bepa_set call)
        return w._Cepa.bepa(self)
    def fepa(w, self):                      # Adding depa
        return w.cepa(self) + w.bepa(self)


====================================================>           # Utilizing single class inheritance....

class Apa[S] ():
    def apa1(w, self):
        return 1
    def apa2(w, self):
        return 2

class Bepa[S] (Apa[S]):
    def apa1(w, self):
        return 10
    def bepa(w, self):
        return w.apa2(self)

class Cepa[S] (Apa[S]):
    # apa1 = Apa.apa1
    def apa2(w, self):
        return 20
    def cepa(w, self):
        return w.apa1(self)

class Bepa_Depa[S] (Bepa[S]):
    _Depa   : Depa[S]
    # apa1 = Bepa.apa1
    def apa2(w, self):
        return w._Depa.apa2(self)
    # bepa = Bepa.bepa

--- extension int (Depa)

class Depa[S] (Cepa[S]):
    _Bepa   : Bepa[S]
    def apa1(w, self):
        return w._Bepa.apa1(self)
    # apa2 = Cepa.apa2
    # cepa = Cepa.cepa
    def bepa(w, self):
        return w._Bepa.bepa(self)
    def depa(w, self):
        return w.cepa(self) + w.bepa(self)

class Depa_int (Depa[int]):
    def __init__(w):
        w._Bepa = Bepa_Depa(w)
    def ipa(w, self):
        return w.depa(self)


--- extension str (Cepa,Bepa)

class Cepa_Bepa_str (Cepa[str]):
    
    class Bepa_wrapped (Bepa[str]):
        _main   : Cepa[str]
        # apa1 = Bepa.apa2                      # Inheriting apa1
        def apa2(w, self):                      # Overriding apa2 (= redirection to Cepa_Bepa_str, in case of Bepa sibling use or Cepa_Bepa_str promotion to Bepa)
            return w._main.apa2(self)
        # bepa = Bepa_str.bepa                  # Inheriting bepa
    
    _Bepa   : Bepa[str]                         # NOTE: real str(Bepa) witness!
    def __init__(w):
        w._Bepa = Bepa_wrapped(_main = w)
    
    def apa1(w, self):
        retun w._Bepa.apa1(self)
    # apa2 = Cepa.apa2
    # cepa = Cepa.cepa
    def bepa(w, self):
        return w._Bepa.bepa(self)
    def fepa(w, self):
        return w.cepa(self) + w.bepa(self)

--- extension str (Bepa); extension str (Cepa)

class Bepa_str (Bepa[str]):
    # apa1 = Bepa.apa1                      # Inheriting apa1
    # apa2 = Bepa.apa2                      # Inheriting apa2
    # bepa = Bepa.bepa                      # Inheriting bepa
    
class Cepa_Bepa_str (Cepa[str]):            # Encoding Cepa_Bepa_str (Cepa[str], Bepa[str])
    
    class Bepa_wrapped (Bepa_str):              # Forms inner baseclass (delegate), but comes before Cepa in the MRO
        _main   : Cepa[str]
        # apa1 = Bepa.apa2                      # Inheriting apa1
        def apa2(w, self):                      # Overriding apa2 (= redirection to Cepa_Bepa_str, in case of Bepa_str sibling use or Cepa_Bepa_str promotion to Bepa)
            return w._main.apa2(self)
        # bepa = Bepa_str.bepa                  # Inheriting bepa
        
    _Bepa   : Bepa[str]                     # NOTE: real str(Bepa) witness!
    def __init__(w):
        w._Bepa = Bepa_wrapped(_main = w)
    
    def apa1(w, self):                      # "Inheriting" apa1 (= delegation to Bepa, in case of Cepa_Bepa_str sibling use or official Cepa_Bepa_str call)
        retun w._Bepa.apa1(self)
    # apa2 = Cepa.apa2                      # Inheriting apa2
    # cepa = Cepa.cepa                      # Inheriting cepa
    def bepa(w, self):                      # "Inheriting" bepa (= delegation to Bepa, in case of Cepa_Bepa_str sibling use or official Cepa_Bepa_str call)
        return w._Bepa.bepa(self)
    def fepa(w, self):
        return w.cepa(self) + w.bepa(self)

--- extension list[A] (Bepa); extension list[A] (Cepa)

class Bepa_list[A] (Bepa[list[A]]):
    # apa1 = Bepa.apa1                      # Inheriting apa1
    # apa2 = Bepa.apa2                      # Inheriting apa2
    # bepa = Bepa.bepa                      # Inheriting bepa
    
class Cepa_Bepa_list[A] (Cepa[list[A]]):    # Encoding Cepa_Bepa_list[A] (Cepa[list[A]], Bepa[list[A]])
    
    class Bepa_wrapped[A] (Bepa_list[A]):       # Forms inner baseclass (delegate), but comes before Cepa in the MRO
        _main   : Cepa[list[A]]
        # apa1 = Bepa.apa2                      # Inheriting apa1
        def apa2(w, self):                      # Overriding apa2 (= redirection to Cepa_Bepa_list, if Bepa_list sibling use or Cepa_Bepa_list prom to Bepa)
            return w._main.apa2(self)
        # bepa = Bepa_list.bepa                 # Inheriting bepa
        
    _Bepa   : Bepa[list[A]]                 # NOTE: real list[A](Bepa) witness!
    def __init__(w):
        w._Bepa = Bepa_wrapped(_main = w)
    
    def apa1(w, self):                      # "Inheriting" apa1 (= delegation to Bepa, in case of Cepa_Bepa_list sibling use or official Cepa_Bepa_list call)
        retun w._Bepa.apa1(self)
    # apa2 = Cepa.apa2                      # Inheriting apa2
    # cepa = Cepa.cepa                      # Inheriting cepa
    def bepa(w, self):                      # "Inheriting" bepa (= delegation to Bepa, in case of Cepa_Bepa_list sibling use or official Cepa_Bepa_list call)
        return w._Bepa.bepa(self)
    def fepa(w, self):
        return w.cepa(self) + w.bepa(self)

--- extension set[A(Eq)] (Bepa); extension set[A(Ord)] (Cepa)

class Bepa_set[A] (Bepa[set[A]]):
    _Eq_A   : Eq[A]
    def __init__(w, _Eq_A):
        w._Eq_A = _Eq_A
    # apa1 = Bepa.apa1                      # Inheriting apa1
    # apa2 = Bepa.apa2                      # Inheriting apa2
    # bepa = Bepa.bepa                      # Inheriting bepa
    
class Cepa_Bepa_set[A] (Cepa[set[A]]):    # Encoding Cepa_Bepa_set[A] (Cepa[set[A]], Bepa[set[A]])
    
    class Bepa_wrapped[A] (Bepa_set[A]):        # Forms inner baseclass (delegate), but comes before Cepa in the MRO
        _main   : Cepa[set[A]]
        # apa1 = Bepa.apa2                      # Inheriting apa1
        def apa2(w, self):                      # Overriding apa2 (= redirection to Cepa_Bepa_set, if Bepa_set sibling use or Cepa_Bepa_set prom to Bepa)
            return w._main.apa2(self)
        # bepa = Bepa_set.bepa                 # Inheriting bepa
        
    _Bepa   : Bepa[set[A]]                 # NOTE: real set[A](Bepa) witness!
    _Ord_A  : Ord[A]
    def __init__(w, _Ord_A):
        w._Bepa = Bepa_wrapped(_main = w, _Eq_A = _Ord_A)           # In general: _Eq_A = some_expr(_Ord_A)
        w._Ord_A = _Ord_A
    
    def apa1(w, self):                      # "Inheriting" apa1 (= delegation to Bepa, in case of Cepa_Bepa_set sibling use or official Cepa_Bepa_set call)
        retun w._Bepa.apa1(self)
    # apa2 = Cepa.apa2                      # Inheriting apa2
    # cepa = Cepa.cepa                      # Inheriting cepa
    def bepa(w, self):                      # "Inheriting" bepa (= delegation to Bepa, in case of Cepa_Bepa_set sibling use or official Cepa_Bepa_set call)
        return w._Bepa.bepa(self)
    def fepa(w, self):
        return w.cepa(self) + w.bepa(self)

