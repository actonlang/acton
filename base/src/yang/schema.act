# YANG schema
#
# This is an object model for YANG schema, based on YANG 1.1 although it should
# mostly work for YANG 1.0 just fine. There is no logic for either schema or
# data validation, so it is possible to represent an invalid schema using this
# model.
#
# There are two levels of object representation. The first level is that of
# statements and is represented by the Statement class. Everything in a YANG
# model is pretty much a statement, so this is a representation fairly close to
# the YANG source code. For example, the order of all statements is preserved,
# so this model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#    }
#
# Would become:
#
#   Statement("module", "foo", substatements=[
#     Statement("prefix", "f"),
#     Statement("namespace", "http://example.com/foo")
#   ])
#
# Whitespace, indentation and comments are not preserved but all parsed
# statements are. Thus if the Statements are rendered back to YANG source, it
# would look exactly like the original source code, presuming the use of
# canonical YANG formatting.
#
# The second level is that of schema nodes and is represented by the SchemaNode
# class. The SchemaNode class is a base class for all schema node types, such as
# Module, Container, List, Leaf, etc. Different statements are modeled using
# discrete classes and statements that relate to a particular statement are
# attributes of that object class rather than being seen as just a tree of
# statements. For example, the following model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# Would become:
#
#   Module("foo", namespace="http://example.com/foo", prefix="f", children=[
#     Container("c1", children=[
#       Leaf("l1", type="string")
#     ])
#   ])
#
# Rendering that back to YANG source code will render the namespace & prefix
# statements in the canonical order specified by the YANG RFC, thus rendering
# the following:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# This higher layer SchemaNode representation is not suitable if it is desirable
# to keep statement order from the original source document (be aware that even
# with the lower leve Statement representation, whitespace & comments are still
# lost).

def _ind(n):
    return "  " * n

_quoted_arg_keywords = set([
    "argument",
    "augment",
    "contact",
    "description",
    "if-feature",
    "namespace",
    "organization",
    "prefix",
    "reference",
    "refine",
    "yang-version",
])

class Statement(object):
    kw: str
    arg: ?str
    prefix: ?str
    substatements: list[Statement]
    def __init__(self, kw: str, arg: ?str=None, prefix: ?str=None):
        self.kw = kw
        self.arg = arg
        self.prefix = prefix
        self.substatements = []

    def get_subarg(self, kw: str) -> ?str:
        for substatement in self.substatements:
            if substatement.kw == kw:
                return substatement.arg

    def get_subarg_bool(self, kw: str) -> ?bool:
        for substatement in self.substatements:
            if substatement.kw == kw:
                arg = substatement.arg
                if arg is not None:
                    return bool(arg)

    def pryang(self, indent=0):
        """Print YANG source code for this statement and its substatements
        """
        res = _ind(indent) + self.kw
        arg = self.arg
        if arg is not None:
            quoted_arg = True if self.kw in _quoted_arg_keywords else False
            res += " "
            if quoted_arg:
                res += '"'
            res += arg
            if quoted_arg:
                res += '"'
        if len(self.substatements) == 0:
            res += ";\n"
        else:
            res += " {\n"
            for substatement in self.substatements:
                res += substatement.pryang(indent+1)
            res += _ind(indent) + "}\n"
        return res

def stmt_to_snode(stmt: Statement):
    def take_bool(stmts: list[Statement], kw: str) -> ?bool:
        v = take_str(stmts, kw)
        if v is not None:
            return bool(v)

    def take_int(stmts: list[Statement], kw: str) -> ?int:
        v = take_str(stmts, kw)
        if v is not None:
            return int(v)

    def take_str(stmts: list[Statement], kw: str) -> ?str:
        for i in range(len(stmts)):
            if stmts[i].kw == kw:
                arg = stmts[i].arg
                if arg is not None:
                    del stmts[i]
                    return arg

    def take_strlist(stmts: list[Statement], kw: str) -> list[str]:
        res = []
        todel = []
        for i in range(len(stmts)):
            if stmts[i].kw == kw:
                arg = stmts[i].arg
                if arg is not None:
                    todel.append(i)
                    res.append(arg)
        for d in reversed(todel):
            del stmts[d]
        return res

    def take_node(stmts: list[Statement], kw: str) -> ?SchemaNode:
        for i in range(len(stmts)):
            if stmts[i].kw == kw:
                n = stmt_to_snode(stmts[i])
                del stmts[i]
                return n

    def take_input(stmts: list[Statement]) -> ?Input:
        n = take_node(stmts, "input")
        if n is not None and isinstance(n, Input):
            return n

    def take_output(stmts: list[Statement]) -> ?Output:
        n = take_node(stmts, "output")
        if n is not None and isinstance(n, Output):
            return n

    def take_nodes(stmts: list[Statement], kw: list[str]) -> list[SchemaNode]:
        res = []
        todel = []
        for i in range(len(stmts)):
            if stmts[i].kw in kw:
                res.append(stmt_to_snode(stmts[i]))
                todel.append(i)
        for i in reversed(todel):
            del stmts[i]
        return res

    def take_imports(stmts: list[Statement]) -> list[Import]:
        res = []
        for node in take_nodes(stmts, ["import"]):
            if isinstance(node, Import):
                res.append(node)
            else:
                raise ValueError("unreachable")
        return res

    def take_include(stmts: list[Statement]) -> list[Include]:
        res = []
        for node in take_nodes(stmts, ["include"]):
            if isinstance(node, Include):
                res.append(node)
            else:
                raise ValueError("unreachable")
        return res

    def take_augment(stmts: list[Statement]) -> list[Augment]:
        res = []
        for node in take_nodes(stmts, ["augment"]):
            if isinstance(node, Augment):
                res.append(node)
            else:
                raise ValueError("unreachable")
        return res

    def take_deviate(stmts: list[Statement]) -> list[Deviate]:
        res = []
        for node in take_nodes(stmts, ["deviate"]):
            if isinstance(node, Deviate):
                res.append(node)
            else:
                raise ValueError("unreachable")
        return res

    def take_must(stmts: list[Statement]) -> list[Must]:
        res = []
        for node in take_nodes(stmts, ["must"]):
            if isinstance(node, Must):
                res.append(node)
            else:
                raise ValueError("unreachable")
        return res

    def take_refine(stmts: list[Statement]) -> list[Refine]:
        res = []
        for node in take_nodes(stmts, ["refine"]):
            if isinstance(node, Refine):
                res.append(node)
            else:
                raise ValueError("unreachable")
        return res

    def take_revision(stmts: list[Statement]) -> list[Revision]:
        res = []
        for node in take_nodes(stmts, ["revision"]):
            if isinstance(node, Revision):
                res.append(node)
            else:
                raise ValueError("unreachable")
        return res


    arg = stmt.arg
    ss = stmt.substatements.copy()
    if stmt.kw == "module":
        if arg is not None:
            n = Module(arg,
                       contact=take_str(ss, "contact"),
                       description=take_str(ss, "description"),
                       import_=take_imports(ss),
                       include=take_include(ss),
                       namespace=take_str(ss, "namespace"),
                       organization=take_str(ss, "organization"),
                       prefix=take_str(ss, "prefix"),
                       reference=take_str(ss, "reference"),
                       revision=take_revision(ss),
                       yang_version=take_str(ss, "yang-version"),
                       children=take_nodes(ss, ["anydata", "anyxml", "augment", "choice", "container", "deviation", "extension", "feature", "grouping", "identity", "leaf", "leaf-list", "list", "notification", "rpc", "typedef", "uses"]),
                       )
            if len(ss) > 0:
                raise ValueError("Invalid statement under module: " + ss[0].kw)
            return n
        raise ValueError("module statement must have an argument")
    elif stmt.kw == "submodule":
        if arg is not None:
            n = Submodule(arg,
                          belongs_to=take_str(ss, "belongs-to"),
                          contact=take_str(ss, "contact"),
                          description=take_str(ss, "description"),
                          import_=take_imports(ss),
                          include=take_include(ss),
                          organization=take_str(ss, "organization"),
                          reference=take_str(ss, "reference"),
                          revision=take_revision(ss),
                          yang_version=take_str(ss, "yang-version"),
                          children=take_nodes(ss, ["anydata", "anyxml", "augment", "choice", "container", "deviation", "extension", "feature", "grouping", "identity", "leaf", "leaf-list", "list", "notification", "rpc", "typedef", "uses"]),
                          )
            if len(ss) > 0:
                raise ValueError("Invalid statement under submodule: " + ss[0].kw)
            return n
        raise ValueError("submodule statement must have an argument")
    elif stmt.kw == "revision":
        if arg is not None:
            n = Revision(arg,
                         description=take_str(ss, "description"),
                         reference=take_str(ss, "reference"),
                         )
            if len(ss) > 0:
                raise ValueError("Invalid statement under revision: " + ss[0].kw)
            return n
        raise ValueError("include statement must have an argument")
    elif stmt.kw == "typedef":
        if arg is not None:
            n = Typedef(arg,
                        default=take_str(ss, "default"),
                        description=take_str(ss, "description"),
                        reference=take_str(ss, "reference"),
                        status=take_str(ss, "status"),
                        type=take_str(ss, "type"),
                        units=take_str(ss, "units"),
                        )
            if len(ss) > 0:
                raise ValueError("Invalid statement under typedef: " + ss[0].kw)
            return n
        raise ValueError("typedef statement must have an argument")
    elif stmt.kw == "container":
        if arg is not None:
            n = Container(arg,
                          config=take_bool(ss, "config"),
                          description=take_str(ss, "description"),
                          presence=take_str(ss, "presence"),
                          reference=take_str(ss, "reference"),
                          status=take_str(ss, "status"),
                          when=take_str(ss, "when"),
                          if_feature=take_strlist(ss, "if-feature"),
                          must=take_must(ss),
                          children=take_nodes(ss, ["action", "anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "notification", "uses"]),
                          )
            if len(ss) > 0:
                raise ValueError("Invalid statement under container: " + ss[0].kw)
            return n
        raise ValueError("container statement must have an argument")
    elif stmt.kw == "leaf":
        if arg is not None:
            n = Leaf(arg,
                     take_str(ss, "type"),
                     config=take_bool(ss, "config"),
                     default=take_str(ss, "default"),
                     description=take_str(ss, "description"),
                     mandatory=take_bool(ss, "mandatory"),
                     reference=take_str(ss, "reference"),
                     status=take_str(ss, "status"),
                     units=take_str(ss, "units"),
                     when=take_str(ss, "when"),
                     if_feature=take_strlist(ss, "if-feature"),
                     must=take_must(ss),
                     )
            if len(ss) > 0:
                raise ValueError("Invalid statement under leaf: ")
                #raise ValueError("Invalid statement under leaf: " + ss[0].kw)
            return n
        raise ValueError("leaf statement must have an argument")
    elif stmt.kw == "leaf-list":
        if arg is not None:
            n = LeafList(arg,
                         config=take_bool(ss, "config"),
                         default=take_str(ss, "default"),
                         description=take_str(ss, "description"),
                         if_feature=take_strlist(ss, "if-feature"),
                         max_elements=take_int(ss, "max-elements"),
                         min_elements=take_int(ss, "min-elements"),
                         must=take_must(ss),
                         ordered_by=take_str(ss, "ordered-by"),
                         reference=take_str(ss, "reference"),
                         status=take_str(ss, "status"),
                         type=take_str(ss, "type"),
                         units=take_str(ss, "units"),
                         when=take_str(ss, "when"),
                         )
            if len(ss) > 0:
                raise ValueError("Invalid statement under leaf-list: " + ss[0].kw)
            return n
        raise ValueError("leaf-list statement must have an argument")
    elif stmt.kw == "list":
        if arg is not None:
            n = List(arg,
                     config=take_bool(ss, "config"),
                     description=take_str(ss, "description"),
                     key=take_strlist(ss, "key"),
                     max_elements=take_int(ss, "max-elements"),
                     min_elements=take_int(ss, "min-elements"),
                     ordered_by=take_str(ss, "ordered-by"),
                     reference=take_str(ss, "reference"),
                     status=take_str(ss, "status"),
                     when=take_str(ss, "when"),
                     if_feature=take_strlist(ss, "if-feature"),
                     must=take_must(ss),
                     children=take_nodes(ss, ["action", "anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "notification", "uses"]),
                     )
            if len(ss) > 0:
                raise ValueError("Invalid statement under list: " + ss[0].kw)
            return n
        raise ValueError("list statement must have an argument")
    elif stmt.kw == "choice":
        if arg is not None:
            n = Choice(arg,
                       config=take_bool(ss, "config"),
                       default=take_str(ss, "default"),
                       description=take_str(ss, "description"),
                       if_feature=take_strlist(ss, "if-feature"),
                       mandatory=take_bool(ss, "mandatory"),
                       reference=take_str(ss, "reference"),
                       status=take_str(ss, "status"),
                       when=take_str(ss, "when"),
                       children=take_nodes(ss, ["anydata", "anyxml", "case", "choice", "container", "leaf", "leaf-list", "list"]),
                       )
            if len(ss) > 0:
                raise ValueError("Invalid statement under choice: " + ss[0].kw)
            return n
        raise ValueError("choice statement must have an argument")
    elif stmt.kw == "anydata":
        if arg is not None:
            n = Anydata(arg,
                        config=take_bool(ss, "config"),
                        description=take_str(ss, "description"),
                        if_feature=take_strlist(ss, "if-feature"),
                        mandatory=take_bool(ss, "mandatory"),
                        must=take_must(ss),
                        reference=take_str(ss, "reference"),
                        status=take_str(ss, "status"),
                        when=take_str(ss, "when"),
                        )
            if len(ss) > 0:
                raise ValueError("Invalid statement under anydata: " + ss[0].kw)
            return n
        raise ValueError("anydata statement must have an argument")
    elif stmt.kw == "anyxml":
        if arg is not None:
            n = Anyxml(arg,
                       config=take_bool(ss, "config"),
                       description=take_str(ss, "description"),
                       mandatory=take_bool(ss, "mandatory"),
                       reference=take_str(ss, "reference"),
                       status=take_str(ss, "status"),
                       when=take_str(ss, "when"),
                       if_feature=take_strlist(ss, "if-feature"),
                       must=take_must(ss),
                       )
            if len(ss) > 0:
                raise ValueError("Invalid statement under anyxml: " + ss[0].kw)
            return n
        raise ValueError("anyxml statement must have an argument")
    elif stmt.kw == "grouping":
        if arg is not None:
            n = Grouping(arg,
                         description=take_str(ss, "description"),
                         reference=take_str(ss, "reference"),
                         status=take_str(ss, "status"),
                         children=take_nodes(ss, ["action", "anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "notification", "typedef", "uses"]),
                         )
            if len(ss) > 0:
                raise ValueError("Invalid statement under grouping: " + ss[0].kw)
            return n
        raise ValueError("grouping statement must have an argument")
    elif stmt.kw == "uses":
        if arg is not None:
            n = Uses(arg,
                     description=take_str(ss, "description"),
                     reference=take_str(ss, "reference"),
                     status=take_str(ss, "status"),
                     when=take_str(ss, "when"),
                     if_feature=take_strlist(ss, "if-feature"),
                     refine=take_refine(ss),
                     augment=take_augment(ss),
                     )
            if len(ss) > 0:
                raise ValueError("Invalid statement under uses: " + ss[0].kw)
            return n
        raise ValueError("uses statement must have an argument")
    elif stmt.kw == "refine":
        if arg is not None:
            n = Refine(arg,
                       default=take_str(ss, "default"),
                       description=take_str(ss, "description"),
                       reference=take_str(ss, "reference"),
                       config=take_bool(ss, "config"),
                       mandatory=take_bool(ss, "mandatory"),
                       presence=take_str(ss, "presence"),
                       max_elements=take_int(ss, "max-elements"),
                       min_elements=take_int(ss, "min-elements"),
                       if_feature=take_strlist(ss, "if-feature"),
                       )
            if len(ss) > 0:
                raise ValueError("Invalid statement under refine: " + ss[0].kw)
            return n
        raise ValueError("rpc statement must have an argument")
    elif stmt.kw == "rpc":
        if arg is not None:
            n = Rpc(arg,
                    description=take_str(ss, "description"),
                    if_feature=take_strlist(ss, "if-feature"),
                    reference=take_str(ss, "reference"),
                    status=take_str(ss, "status"),
                    input=take_input(ss),
                    output=take_output(ss),
                    )
            if len(ss) > 0:
                raise ValueError("Invalid statement under rpc: " + ss[0].kw)
            return n
        raise ValueError("rpc statement must have an argument")
    elif stmt.kw == "input":
        if arg is None:
            n = Input(must=take_must(ss),
                      children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "typedef", "uses"]))
            if len(ss) > 0:
                raise ValueError("Invalid statement under input: " + ss[0].kw)
            return n
        raise ValueError("input statement must not have an argument")
    elif stmt.kw == "output":
        if arg is None:
            n = Output(must=take_must(ss),
                       children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "typedef", "uses"]))
            if len(ss) > 0:
                raise ValueError("Invalid statement under output: " + ss[0].kw)
            return n
        raise ValueError("output statement must not have an argument")
    elif stmt.kw == "action":
        if arg is not None:
            n = Action(arg,
                       description=take_str(ss, "description"),
                       if_feature=take_strlist(ss, "if-feature"),
                       reference=take_str(ss, "reference"),
                       status=take_str(ss, "status"),
                       input=take_input(ss),
                       output=take_output(ss),
                       children=take_nodes(ss, ["grouping", "typedef"]),
                       )
            if len(ss) > 0:
                raise ValueError("Invalid statement under action: " + ss[0].kw)
            return n
        raise ValueError("action statement must have an argument")
    elif stmt.kw == "notification":
        if arg is not None:
            n = Notification(arg,
                             description=take_str(ss, "description"),
                             if_feature=take_strlist(ss, "if-feature"),
                             reference=take_str(ss, "reference"),
                             status=take_str(ss, "status"),
                             children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "typedef", "uses"]),
                             )
            if len(ss) > 0:
                raise ValueError("Invalid statement under notification: " + ss[0].kw)
            return n
        raise ValueError("notification statement must have an argument")
    elif stmt.kw == "augment":
        if arg is not None:
            n = Augment(arg,
                        description=take_str(ss, "description"),
                        if_feature=take_strlist(ss, "if-feature"),
                        reference=take_str(ss, "reference"),
                        when=take_str(ss, "when"),
                        children=take_nodes(ss, ["action", "anydata", "anyxml", "case", "choice", "container", "description", "grouping", "leaf", "leaf-list", "list", "notification", "reference", "uses"]),
                        )
            return n
        raise ValueError("augment statement must have an argument")
    elif stmt.kw == "identity":
        if arg is not None:
            n = Identity(arg,
                         base=take_strlist(ss, "base"),
                         description=take_str(ss, "description"),
                         if_feature=take_strlist(ss, "if-feature"),
                         reference=take_str(ss, "reference"),
                         status=take_str(ss, "status"),
                         )
            if len(ss) > 0:
                raise ValueError("Invalid statement under identity: " + ss[0].kw)
            return n
        raise ValueError("identity statement must have an argument")
    elif stmt.kw == "extension":
        if arg is not None:
            n = Extension(arg,
                          argument=take_str(ss, "argument"),
                          description=take_str(ss, "description"),
                          reference=take_str(ss, "reference"),
                          status=take_str(ss, "status"),
                          )
            if len(ss) > 0:
                raise ValueError("Invalid statement under extension: " + ss[0].kw)
            return n
        raise ValueError("extension statement must have an argument")
    elif stmt.kw == "feature":
        if arg is not None:
            n = Feature(arg,
                        description=take_str(ss, "description"),
                        if_feature=take_strlist(ss, "if-feature"),
                        reference=take_str(ss, "reference"),
                        status=take_str(ss, "status"),
                        )
            if len(ss) > 0:
                raise ValueError("Invalid statement under feature: " + ss[0].kw)
            return n
        raise ValueError("feature statement must have an argument")
    elif stmt.kw == "deviation":
        if arg is not None:
            n = Deviation(arg,
                          description=take_str(ss, "description"),
                          reference=take_str(ss, "reference"),
                          deviate=take_deviate(ss),
                          )
            return n
        raise ValueError("deviation statement must have an argument")
    elif stmt.kw == "import":
        if arg is not None:
            n = Import(arg,
                       description=take_str(ss, "description"),
                       prefix=take_str(ss, "prefix"),
                       reference=take_str(ss, "reference"),
                       revision_date=take_str(ss, "revision-date"),
                       )
            if len(ss) > 0:
                raise ValueError("Invalid statement under import: " + ss[0].kw)
            return n
        raise ValueError("import statement must have an argument")
    elif stmt.kw == "include":
        if arg is not None:
            n = Include(arg,
                        description=take_str(ss, "description"),
                        reference=take_str(ss, "reference"),
                        revision_date=take_str(ss, "revision-date"),
                        )
            if len(ss) > 0:
                raise ValueError("Invalid statement under include: " + ss[0].kw)
            return n
        raise ValueError("include statement must have an argument")
    else:
        raise ValueError("Unknown statement type: " + stmt.kw)


def prsrc_mAdd(name, value):
    if value is not None:
        return ", " + name + "=" + repr(value)
    return ""

def _prsrc(attrs: list[(name, value)]):
    for attr in attrs:
        name, value = attr
        if value is not None:
            return ", " + name + "=" + repr(value)
    return ""

class SchemaNode(object):
    parent: ?SchemaNode
    def prsrc(self, indent=0):
        """Print Acton source code for this schema node and its subnodes
        """
        raise NotImplementedError('')

class Revision(SchemaNode):
    """YANG revision

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.1.9
    """
    date: str
    description: ?str
    reference: ?str

    def __init__(self, date, description=None, reference=None):
        self.parent = None
        self.date = date
        self.description = description
        self.reference = reference

    def prsrc(self, indent=0):
        res = _ind(indent) + 'Revision("' + self.date + '"'
        res += _prsrc("description", self.description)
        res += _prsrc("reference", self.reference)
        res += "),\n"
        return res

class Module(SchemaNode):
    """YANG module

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.1
    """
    name: str
    contact: ?str
    description: ?str
    import_: list[Import]
    include: list[Include]
    namespace: ?str
    organization: ?str
    prefix: ?str
    reference: ?str
    revision: list[Revision]
    yang_version: ?str

    # TODO: use Union to list allowed types instead of inheritance
    # children: list[Union[Anydata, Anyxml, Augment, Choice, Container, Deviation, Extension, Feature, Grouping, Identity, Leaf, LeafList, List, Notification, Rpc, Typedef, Uses]]
    children: list[SchemaNode]

    def __init__(self, name, contact=None, description=None, import_=[], include=[], namespace=None, organization=None, prefix=None, reference=None, revision=[], yang_version=None, children=[]):
        self.parent = None
        self.name = name
        self.contact = contact
        self.description = description
        self.import_ = import_
        self.include = include
        self.namespace = namespace
        self.organization = organization
        self.prefix = prefix
        self.reference = reference
        self.revision = revision
        self.yang_version = yang_version
        self.children = children

    def prsrc(self, indent=0):
        res = _ind(indent) + 'Module("' + self.name + '"'
        res += prsrc_mAdd("namespace", self.namespace)
        res += prsrc_mAdd("prefix", self.prefix)
        res += prsrc_mAdd("yang_version", self.yang_version)
        res += prsrc_mAdd("organization", self.organization)
        res += prsrc_mAdd("contact", self.contact)
        res += prsrc_mAdd("description", self.description)
        res += prsrc_mAdd("reference", self.reference)
        # TODO: handle revision
        #for rev in self.revision:
        #    res += ",\n" + _ind(indent+1) + "revision=" + rev.prsrc(indent+1)
        if len(self.children) > 0:
            res += ", children=[\n"
            for child in self.children:
                res += child.prsrc(indent+1)
            res += _ind(indent) + "]"
        res += "),\n"
        return res

class Action(SchemaNode):
    """YANG action

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.15
    """
    name: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str

    input: ?Input
    output: ?Output

    # TODO: use a Union instead, see https://www.rfc-editor.org/rfc/rfc7950.html#section-7.15.1
    # children: list[Union[Grouping, Typedef]]
    children: list[SchemaNode]

    def __init__(self, name, description=None, if_feature=[], reference=None, status=None, input=None, output=None, children=[]):
        self.parent = None
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.input = input
        self.output = output
        self.children = children

class Anydata(SchemaNode):
    """YANG anydata

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.10
    """
    name: str
    config: ?bool
    description: ?str
    if_feature: list[str]
    mandatory: bool
    must: list[Must]
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name, config=None, description=None, if_feature=[], mandatory=False, must=[], reference=None, status=None, when=None):
        self.parent = None
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.when = when

class Anyxml(SchemaNode):
    """YANG anyxml

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.11
    """
    name: str
    config: ?bool
    description: ?str
    if_feature: list[str]
    mandatory: bool
    must: list[Must]
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name, config=None, description=None, if_feature=[], mandatory=False, must=[], reference=None, status=None, when=None):
        self.parent = None
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.when = when

class Choice(SchemaNode):
    """YANG choice

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.9
    """
    name: str
    config: ?bool
    default: ?str
    description: ?str
    if_feature: list[str]
    mandatory: ?bool
    reference: ?str
    status: ?str
    when: ?str

    # TODO: use Union to list allowed types instead of inheritance
    # children: list[Union[Anydata, Anyxml, Case, Choice, Container, Leaf, LeafList, List]]
    children: list[SchemaNode]

    def __init__(self, name, config=None, default=None, description=None, if_feature=[], mandatory=None, reference=None, status=None, when=None, children=[]):
        self.parent = None
        self.name = name
        self.config = config
        self.default = default
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.reference = reference
        self.status = status
        self.when = when
        self.children = children

class Container(SchemaNode):
    """YANG container

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.5
    """
    name: str
    config: ?bool
    description: ?str
    presence: ?str
    reference: ?str
    status: ?str
    when: ?str
    must: list[Must]
    if_feature: list[str]

    # TODO: use Union to list allowed types instead of inheritance, see
    #       https://www.rfc-editor.org/rfc/rfc7950.html#section-7.5.6
    # children: list[Union[Container, Leaf, LeafList, Uses, Choice, Anydata, Anyxml]]
    children: list[SchemaNode]

    def __init__(self, name, config=None, description=None, presence=None, reference=None, status=None, when=None, must=[], if_feature=[], children=[]):
        self.parent = None
        self.name = name
        self.config = config
        self.description = description
        self.presence = presence
        self.reference = reference
        self.status = status
        self.when = when
        self.must = must
        self.if_feature = if_feature
        self.children = children

    def prsrc(self, indent=0):
        res = _ind(indent) + 'Container("' + self.name + '"'
        res += prsrc_mAdd("config", self.config)
        res += prsrc_mAdd("description", self.description)
        res += prsrc_mAdd("presence", self.presence)
        res += prsrc_mAdd("reference", self.reference)
        res += prsrc_mAdd("status", self.status)
        res += prsrc_mAdd("when", self.when)
        if len(self.children) > 0:
            res += ", children=[\n"
            for child in self.children:
                res += child.prsrc(indent+1)
            res += _ind(indent) + "]"
        res += "),\n"
        return res

class Deviation(SchemaNode):
    """YANG deviation

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.20.3
    """
    target: str
    description: ?str
    reference: ?str
    deviate: list[Deviate]
    def __init__(self, target, description=None, reference=None, deviate=[]):
        self.parent = None
        self.target = target
        self.description = description
        self.reference = reference
        self.deviate = deviate

class Deviate(object):
    """YANG deviate

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.20.3.2
    """
    kind: str
    config: ?bool
    default: list[str]
    mandatory: ?bool
    max_elements: ?int
    min_elements: ?int
    must: list[Must]
    type: ?str
    unique: list[str]
    units: ?str

    def __init__(self, kind, config=None, default=[], mandatory=None, max_elements=None, min_elements=None, must=[], type=None, unique=[], units=None):
        self.parent = None
        self.kind = kind
        self.config = config
        self.default = default
        self.mandatory = mandatory
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.type = type
        self.unique = unique
        self.units = units

class Extension(SchemaNode):
    """YANG extension

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.19
    """
    name: str
    argument: ?str
    description: ?str
    reference: ?str
    status: ?str

    def __init__(self, name, argument=None, description=None, reference=None, status=None):
        self.parent = None
        self.name = name
        self.argument = argument
        self.description = description
        self.reference = reference
        self.status = status

class ExtensionInstance(SchemaNode):
    """YANG extension instance

    All other nodes in the SchemaNode model are represented by classes since
    they are known from the definition of the YANG standard. The whole point of
    extensions is that they extend the language itself. Therefore, we cannot
    know what kind of node an extension instance represents and instead represent
    it as a generic ExtensionInstance class.

    https://www.rfc-editor.org/rfc/rfc7950.html#section-6.3.1
    """
    name: str
    children: list[SchemaNode]
    def __init__(self, name, children=[]):
        self.parent = None
        self.name = name
        self.children = children

class Feature(SchemaNode):
    """YANG feature

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.201
    """
    name: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str

    def __init__(self, name, description=None, if_feature=[], reference=None, status=None):
        self.parent = None
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status

class Grouping(SchemaNode):
    """YANG grouping

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.12
    """
    name: str
    description: ?str
    reference: ?str
    status: ?str

    # children: list[Union[Action, Anydata, Anyxml, Choice, Container, Grouping, Leaf, LeafList, List, Notification, Typedef, Uses]]
    children: list[SchemaNode]

    def __init__(self, name, description=None, reference=None, status=None, children=[]):
        self.parent = None
        self.name = name
        self.description = description
        self.reference = reference
        self.status = status
        self.children = children

class Identity(SchemaNode):
    """YANG identity

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.18
    """
    name: str
    base: list[str]
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str

    def __init__(self, name, base=[], description=None, if_feature=[], reference=None, status=None):
        self.parent = None
        self.name = name
        self.base = base
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status

class Import(SchemaNode):
    """YANG import

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.1.5
    """
    name: str
    description: ?str
    prefix: ?str
    reference: ?str
    revision_date: ?str

    def __init__(self, name, description=None, prefix=None, reference=None, revision_date=None):
        self.parent = None
        self.name = name
        self.description = description
        self.prefix = prefix
        self.reference = reference
        self.revision_date = revision_date

class Include(SchemaNode):
    """YANG include

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.1.6
    """
    name: str
    description: ?str
    reference: ?str
    revision_date: ?str

    def __init__(self, name, description=None, reference=None, revision_date=None):
        self.parent = None
        self.name = name
        self.description = description
        self.reference = reference
        self.revision_date = revision_date

class Leaf(SchemaNode):
    """YANG leaf

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.6
    """
    name: str
    type: ?str
    config: ?bool
    default: ?str
    description: ?str
    mandatory: bool
    reference: ?str
    status: ?str
    units: ?str
    when: ?str
    must: list[Must]
    if_feature: list[str]

    def __init__(self, name, type=None, config=None, default=None, description=None, mandatory=False, reference=None, status=None, units=None, when=None, must=[], if_feature=[]):
        self.parent = None
        self.name = name
        self.type = type
        self.config = config
        self.default = default
        self.description = description
        self.mandatory = mandatory
        self.reference = reference
        self.status = status
        self.units = units
        self.when = when
        self.must = must
        self.if_feature = if_feature

    def prsrc(self, indent=0):
        res = _ind(indent) + 'Leaf("' + self.name + '"'
        res += prsrc_mAdd("type", self.type)
        res += prsrc_mAdd("config", self.config)
        res += prsrc_mAdd("default", self.default)
        res += prsrc_mAdd("description", self.description)
        res += prsrc_mAdd("mandatory", self.mandatory)
        res += prsrc_mAdd("reference", self.reference)
        res += prsrc_mAdd("status", self.status)
        res += prsrc_mAdd("units", self.units)
        res += prsrc_mAdd("when", self.when)
        # TODO: handle must
        #res += prsrc_mAdd("must", self.must)
        # TODO: handle if_feature
        #res += prsrc_mAdd("if_feature", self.if_feature)
        res += "),\n"
        return res

class LeafList(SchemaNode):
    """YANG leaf-list

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.7
    """
    name: str
    config: ?bool
    default: ?str
    description: ?str
    if_feature: list[str]
    max_elements: ?int
    min_elements: ?int
    must: list[Must]
    ordered_by: ?str
    reference: ?str
    status: ?str
    type: ?str
    units: ?str
    when: ?str

    def __init__(self, name, config=None, default=None, description=None, if_feature=[], max_elements=None, min_elements=None, must=[], ordered_by=None, reference=None, status=None, type=None, units=None, when=None):
        self.parent = None
        self.name = name
        self.config = config
        self.default = default
        self.description = description
        self.if_feature = if_feature
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.type = type
        self.units = units
        self.when = when

class List(SchemaNode):
    """YANG list

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.8
    """
    name: str
    config: ?bool
    description: ?str
    if_feature: list[str]
    key: list[str]
    max_elements: ?int
    min_elements: ?int
    must: list[Must]
    ordered_by: ?str
    reference: ?str
    status: ?str
    unique: list[str]
    when: ?str

    # TODO: use Union to list allowed types instead of inheritance
    # children: list[Union[Action, Anydata, Anyxml, Choice, Container, Grouping, Leaf, LeafList, List, Notification, Typedef, Uses]]
    children: list[SchemaNode]

    def __init__(self, name, config=None, description=None, if_feature=[], key=[], max_elements=None, min_elements=None, must=[], ordered_by=None, reference=None, status=None, unique=[], when=None, children=[]):
        self.parent = None
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.key = key
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.unique = unique
        self.when = when
        self.children = children

class Notification(SchemaNode):
    """YANG notification

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.16
    """
    name: str
    description: ?str
    if_feature: list[str]
    must: list[Must]
    reference: ?str
    status: ?str

    # TODO: use Union to list allowed types instead of inheritance
    # children: list[Union[Anydata, Anyxml, Choice, Container, Grouping, Leaf, LeafList, List, Typedef, Uses]]
    children: list[SchemaNode]

    def __init__(self, name, description=None, if_feature=[], must=[], reference=None, status=None, children=[]):
        self.parent = None
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.must = must
        self.reference = reference
        self.status = status
        self.children = children

class Rpc(SchemaNode):
    """YANG rpc

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.14
    """
    name: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str

    input: ?Input
    output: ?Output

    def __init__(self, name, description=None, if_feature=[], reference=None, status=None, input=None, output=None):
        self.parent = None
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.input = input
        self.output = output

class Input(SchemaNode):
    """YANG input

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.14.2
    """
    must: list[Must]

    children: list[SchemaNode]

    def __init__(self, must=[], children=[]):
        self.parent = None
        self.must = must
        self.children = children

class Output(SchemaNode):
    """YANG input

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.14.3
    """
    must: list[Must]

    children: list[SchemaNode]

    def __init__(self, must=[], children=[]):
        self.parent = None
        self.must = must
        self.children = children

class Type(SchemaNode):
    """YANG type

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.6.3
    """
    name: str
    base: ?str
    bit: list[Bit]
    enum: list[Enum]
    fraction_digits: ?int
    length: ?str
    path: ?str
    pattern: ?str
    range: ?str
    require_instance: bool
    type: ?str

    def __init__(self, name, base=None, bit=[], enum=[], fraction_digits=None, length=None, path=None, pattern=None, range=None, require_instance=False, type=None):
        self.parent = None
        self.name = name
        self.base = base
        self.bit = bit
        self.enum = enum
        self.fraction_digits = fraction_digits
        self.length = length
        self.path = path
        self.pattern = pattern
        self.range = range
        self.require_instance = require_instance
        self.type = type

class Bit(SchemaNode):
    """YANG bit

    https://www.rfc-editor.org/rfc/rfc7950.html#section-9.7
    """
    name: str
    position: int
    description: ?str
    reference: ?str
    status: ?str
    if_feature: list[str]

    def __init__(self, name, position, description=None, reference=None, status=None, if_feature=[]):
        self.parent = None
        self.name = name
        self.position = position
        self.description = description
        self.reference = reference
        self.status = status
        self.if_feature = if_feature

class Enum(SchemaNode):
    """YANG enum

    https://www.rfc-editor.org/rfc/rfc7950.html#section-9.6.4
    """
    name: str
    description: ?str
    value: ?str
    reference: ?str
    status: ?str
    if_feature: list[str]

    def __init__(self, name, description=None, value=None, reference=None, status=None, if_feature=[]):
        self.parent = None
        self.name = name
        self.description = description
        self.value = value
        self.reference = reference
        self.status = status
        self.if_feature = if_feature

class Typedef(SchemaNode):
    """YANG typedef

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.3
    """
    name: str
    default: ?str
    description: ?str
    reference: ?str
    status: ?str
    type: ?str
    units: ?str

    def __init__(self, name, type, default=None, description=None, reference=None, status=None, units=None):
        self.parent = None
        self.name = name
        self.default = default
        self.description = description
        self.reference = reference
        self.status = status
        self.type = type
        self.units = units

class Uses(SchemaNode):
    """YANG uses

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.13
    """
    name: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str
    when: ?str

    augment: list[Augment]
    refine: list[Refine]

    def __init__(self, name, description=None, if_feature=[], reference=None, status=None, when=None, augment=[], refine=[]):
        self.parent = None
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.when = when
        self.augment = augment
        self.refine = refine

class Augment(SchemaNode):
    """YANG augment

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.17
    """
    target: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    when: ?str

    # TODO: use Union to list allowed types instead of inheritance
    # children: list[Union[Action, Anydata, Anyxml, Case, Choice, Container, Leaf, LeafList, List, Notification, Uses]]
    children: list[SchemaNode]

    def __init__(self, target, description=None, if_feature=[], reference=None, when=None, children=[]):
        self.parent = None
        self.target = target
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.when = when
        self.children = children

class Refine(SchemaNode):
    """YANG refine

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.13.2
    """
    target: str
    default: ?str
    description: ?str
    reference: ?str
    config: ?bool
    mandatory: ?bool
    presence: ?str
    must: list[Must]
    max_elements: ?int
    min_elements: ?int
    if_feature: list[str]
    # TODO: support extensions!?
    #ext: list[Extension]
    def __init__(self, target, default=None, description=None, reference=None, config=None, mandatory=None, presence=None, must=[], max_elements=None, min_elements=None, if_feature=[]):
        self.parent = None
        self.target = target
        self.default = default
        self.description = description
        self.reference = reference
        self.config = config
        self.mandatory = mandatory
        self.presence = presence
        self.must = must
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.if_feature = if_feature

class Submodule(SchemaNode):
    """YANG submodule

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.2
    """
    name: str
    belongs_to: ?str
    contact: ?str
    description: ?str
    import_: list[Import]
    include: list[Include]
    organization: ?str
    reference: ?str
    revision: list[Revision]
    yang_version: ?str

    children: list[SchemaNode]

    def __init__(self, name, belongs_to=None, contact=None, description=None, import_=[], include=[], organization=None, reference=None, revision=[], yang_version=None, children=[]):
        self.parent = None
        self.name = name
        self.belongs_to = belongs_to
        self.contact = contact
        self.description = description
        self.import_ = import_
        self.include = include
        self.organization = organization
        self.reference = reference
        self.revision = revision
        self.yang_version = yang_version
        self.children = children


class Must(SchemaNode):
    """YANG must

    https://www.rfc-editor.org/rfc/rfc7950.html#section-7.5.3
    """
    xpath: str
    description: ?str
    error_app_tag: ?str
    error_message: ?str
    reference: ?str

    def __init__(self, xpath, description=None, error_app_tag=None, error_message=None, reference=None):
        self.parent = None
        self.xpath = xpath
        self.description = description
        self.error_app_tag = error_app_tag
        self.error_message = error_message
        self.reference = reference
