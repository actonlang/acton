def gc(cap: SysCap) -> None:
    NotImplemented

# sleep is sort of dangerous - it will actually put the RTS thread executing the
# actor calling this function to sleep. This could be seen as ultrabad, like we
# would want to just pause execution of one actor and let the RTS thread process
# other actors meanwhile. There would be room for such a function, however, the
# acton.rts.sleep() is deliberately putting the RTS thread to sleep. This is a
# simple way of simulating heavy work without actually doing the heavy work, so
# in a benchmark we can pretend some actors are doing relatively heavy work, yet
# our CPU usage will be lower, so this is like laptop airplane mode friendly
# (consumes less battery).
def sleep(cap: SysCap, duration: float) -> None:
    """Put RTS worker thread to sleep"""
    NotImplemented

def rss(cap: SysCap) -> int:
    """Get Resident Set Size"""
    NotImplemented

def _io_handles(cap: SysCap) -> dict[u64, (typ: str, act: u64)]:
    """Return all I/O handles and their type for the current worker thread"""
    NotImplemented

actor WThreadMonitor(env: Env, arg_wthread_id: int):
    wthread_id = arg_wthread_id

    def io_handles():
        return _io_handles(env.syscap)

    proc def _init():
        """Implementation internal"""
        NotImplemented
    _init()

actor Monitor(env: Env):
    tms: dict[int, WThreadMonitor] = {}

    for wthread_id in range(1, env.nr_wthreads+1, 1):
        tm = WThreadMonitor(env, wthread_id)
        tms[wthread_id] = tm

    def io_handles():
        res = {}
        for wthread_id, tm in tms.items():
            res[wthread_id] = tm.io_handles()
        return res

