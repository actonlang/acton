
import acton.rts
import argparse
import json
import logging
import term
import time

# -- assert ---------------------------------------------------------------------

# TODO: add actual values as args to assert functions
# TODO: add __str__ to assert exceptions
class NotEqualError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None
        self.b = None

class EqualError(AssertionError):
    def __init__(self, msg, a, b):
        self.error_message = msg
        self.a = None
        self.b = None

class NotTrueError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None

class NotFalseError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None

class NotNoneError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None

class NoneError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None

class NotInError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None
        self.b = None

class InError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None
        self.b = None

class NotIsError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None
        self.b = None

class IsError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None
        self.b = None

class NotRaisesError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None

class IsInstanceError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None
        self.b = None

class NotIsInstanceError(AssertionError):
    def __init__(self, msg):
        self.error_message = msg
        self.a = None
        self.b = None


def assertEqual(a, b, msg: str):
    if not (a == b):
        assert_msg = "Expected equal values but they are non-equal"
        if msg != "":
            assert_msg += ": " + msg
        # TODO: include actual values in error message
        raise NotEqualError(assert_msg)

def assertNotEqual(a, b, msg: str):
    if not (a != b):
        assert_msg = "Expected non-equal values but they are equal"
        if msg != "":
            assert_msg += ": " + msg
        raise EqualError(assert_msg, a, b)

def assertTrue(a, msg: str):
    if not bool(a):
        assert_msg = "Expected True but got False"
        if msg != "":
            assert_msg += ": " + msg
        raise NotTrueError(assert_msg)

def assertFalse(a, msg: str):
    if bool(a):
        assert_msg = "Expected False but got True"
        if msg != "":
            assert_msg += ": " + msg
        # TODO: include actual values in error message
        raise NotFalseError(assert_msg)

# We cannot test raises right now because we need better support for taking a
# function and its arguments as parameters or run as a context manager
# TODO: assertRaises
# TODO: assertRaisesWithMessage
# TODO: assertRaisesWithMessageRegex

# TODO: fix this
#def assertIs(a, b, msg: str):
#    if not (a is b):
#        assert_msg = "Expected same objects but they are different"
#        if msg != "":
#            assert_msg += ": " + msg
#        # TODO: include actual values in error message
#        raise NotIsError(assert_msg)
#
#def assertIsNot(a, b, msg: str):
#    if not (a is not b):
#        assert_msg = "Expected different objects but they are the same"
#        if msg != "":
#            assert_msg += ": " + msg
#        # TODO: include actual values in error message
#        raise IsError(assert_msg)

def assertIsNone(a, msg: str):
    if not (a is None):
        assert_msg = "Expected None but got non-None"
        if msg != "":
            assert_msg += ": " + msg
        # TODO: include actual values in error message
        raise NotNoneError(assert_msg)

def assertIsNotNone(a, msg: str):
    if not (a is not None):
        assert_msg = "Expected non-None but got None"
        if msg != "":
            assert_msg += ": " + msg
        # TODO: include actual values in error message
        raise NoneError(assert_msg)

def assertIn(a, b, msg: str):
    if not (a in b):
        assert_msg = "Expected value to be in collection but it is not"
        if msg != "":
            assert_msg += ": " + msg
        # TODO: include actual values in error message
        raise NotInError(assert_msg)

def assertNotIn(a, b, msg: str):
    if a in b:
        assert_msg = "Expected value to not be in collection but it is"
        if msg != "":
            assert_msg += ": " + msg
        # TODO: include actual values in error message
        raise InError(assert_msg)

# TODO: fix this?
#def assertIsInstance(a, b, msg: str):
#    if not isinstance(a, b):
#        assert_msg = "Expected instance of " + b + " but got non-instance"
#        if msg != "":
#            assert_msg += ": " + msg
#        raise NotIsInstanceError(assert_msg)
#
#def assertNotIsInstance(a, b, msg: str):
#    if isinstance(a, b):
#        assert_msg = "Expected not instance of " + b + " but got instance"
#        if msg != "":
#            assert_msg += ": " + msg
#        raise IsInstanceError(assert_msg)

# -------------------------------------------------------------------------------

class TestLogger(logging.Logger):
    pass

class Test (object):
    name: str
    desc: str

    def __init__(self, name: str, desc: str):
        self.name = name
        self.desc = desc

    def to_json(self):
        return {
            "name": self.name,
            "desc": self.desc,
        }


class UnitTest(Test):
    def __init__(self, fn: mut() -> None, name: str, desc: str):
        self.fn = fn
        self.name = name
        self.desc = desc

class SyncActorTest(Test):
    def __init__(self, fn: proc(logging.Handler) -> None, name: str, desc: str):
        self.fn = fn
        self.name = name
        self.desc = desc

class AsyncActorTest(Test):
    def __init__(self, fn: proc(action(?bool, ?Exception) -> None, logging.Handler) -> None, name: str, desc: str):
        self.fn = fn
        self.name = name
        self.desc = desc

class EnvTest(Test):
    def __init__(self, fn: proc(action(?bool, ?Exception) -> None, Env, logging.Handler) -> None, name: str, desc: str):
        self.fn = fn
        self.name = name
        self.desc = desc


class TestResult(object):
    """
    There are three possible outcomes for a test:
    - success: the test ran to completion with the expected results
      - for unit tests & synchronous actor tests, it means it returned `None`
      - for asynchronous actor & env tests, the report_result callback was called with TestResult(success=True, exception=None)
    - failure: the test encountered an unexpected value
      - for unit tests & synchronous actor tests, an AssertionError (or child thereof) was raiesd
      - for asynchronous actor & env tests, the report_result callback was called with TestResult(success=False, exception=AssertionError)
    - error: the test was unable to run to completion, encountering some other error in test setup or similar
      - for unit tests & synchronous actor tests, an Exception (or child thereof) was raised, but not an AssertionError
      - for asynchronous actor & env tests, the report_result callback was called with TestResult(success=, exception=AssertionError)
    """
    success: ?bool
    exception: ?str
    duration: float

    def __init__(self, success: ?bool, exception: ?str, duration: float):
        self.success = success
        self.exception = exception
        self.duration = duration

    def to_json(self):
        res = {}
        success = self.success
        exception = self.exception
        duration = self.duration
        if success is not None:
            res["success"] = success
        if exception is not None:
            res["exception"] = exception
        if duration is not None:
            res["duration"] = duration
        return res

actor unit_test_runner(i, get_test, report_result):
    """Test runner for unit tests
    """
    def _run():
        while True:
            t = get_test()
            if t is not None:
                sw = time.Stopwatch()
                f = t.fn
                try:
                    f()
                    dur = sw.elapsed().to_float() * 1000.0
                    report_result(t, TestResult(True, None, dur))
                except AssertionError as e:
                    dur = sw.elapsed().to_float() * 1000.0
                    report_result(t, TestResult(None, str(e), dur))
                except Exception as e:
                    dur = sw.elapsed().to_float() * 1000.0
                    report_result(t, TestResult(False, str(e), dur))
            else:
                return None

    after 0: _run()


actor sync_actor_test_runner(get_test: action() -> ?SyncActorTest, report_result):
    """Test runner for sync actor tests
    """
    log_handler = logging.Handler("TestRunner")
    def _run():
        while True:
            t = get_test()
            if t is not None:
                sw = time.Stopwatch()
                f = t.fn
                try:
                    f(log_handler)
                    dur = sw.elapsed().to_float() * 1000.0
                    report_result(t, TestResult(True, None, dur))
                except AssertionError as e:
                    dur = sw.elapsed().to_float() * 1000.0
                    report_result(t, TestResult(None, str(e), dur))
                except Exception as e:
                    dur = sw.elapsed().to_float() * 1000.0
                    report_result(t, TestResult(False, str(e), dur))
            else:
                return None

    after 0: _run()


actor async_actor_test_runner(get_test: action() -> ?AsyncActorTest, report_result):
    """Test runner for async actor tests
    """
    log_handler = logging.Handler("TestRunner")

    action def _report_result(test: AsyncActorTest, sw, success: ?bool, exception: ?Exception):
        dur = sw.elapsed().to_float() * 1000.0
        exc = None
        if exception is not None:
            exc = str(exception)
        report_result(test, TestResult(success, exc, dur))

    def _run():
        while True:
            t = get_test()
            if t is not None:
                sw = time.Stopwatch()
                f = t.fn
                try:
                    f(lambda s, e: _report_result(t, sw, s, e), log_handler)
                except AssertionError as e:
                    dur = sw.elapsed().to_float() * 1000.0
                    report_result(t, TestResult(None, str(e), dur))
                except Exception as e:
                    dur = sw.elapsed().to_float() * 1000.0
                    report_result(t, TestResult(False, str(e), dur))
            else:
                return None

    after 0: _run()


actor env_test_runner(get_test: action() -> ?EnvTest, report_result, env):
    """Test runner for async actor tests
    """
    log_handler = logging.Handler("TestRunner")

    action def _report_result(test: EnvTest, sw, success: ?bool, exception: ?Exception):
        dur = sw.elapsed().to_float() * 1000.0
        exc = None
        if exception is not None:
            exc = str(exception)
        report_result(test, TestResult(success, exc, dur))

    def _run():
        while True:
            t = get_test()
            if t is not None:
                sw = time.Stopwatch()
                f = t.fn
                try:
                    f(lambda s, e: _report_result(t, sw, s, e), env, log_handler)
                except AssertionError as e:
                    dur = sw.elapsed().to_float() * 1000.0
                    report_result(t, TestResult(None, str(e), dur))
                except Exception as e:
                    dur = sw.elapsed().to_float() * 1000.0
                    report_result(t, TestResult(False, str(e), dur))
            else:
                return None

    after 0: _run()


class TestDisplay(object):
    results: dict[str, dict[str, (test: Test, result: ?TestResult)]]
    expected_modules: set[str]

    def __init__(self, env):
        self._env = env
        self.results = {}
        self.sw = time.Stopwatch()
        self.expected_modules = set([''])

    def update(self, test: Test, test_result: ?TestResult, modname: str=""):
        """Will return an integer when all tests are complete, otherwise None
        The returned integer is the suggested exit code.
        """
        if modname not in self.results:
            self.results[modname] = {}
        self.results[modname][test.name] = (test=test, result=test_result)
        if test_result is not None:
            self.show()

    def show(self):
        pass

class TestDisplayJSON(TestDisplay):
#    def update_from_json(self, json_update: str):
#        update = json.decode(json_update)

    def show(self):
        res = {}
        for modname in self.results:
            #if modname not in res:
            #    res[modname] = {}
            for tname, t in self.results[modname].items():
                tres = {}
                r = t.result
                if r is not None:
                    tres = r.to_json()
                #res[modname][tname] = {"test": t.test.to_json(), "result": tres}
                res[modname + "." + tname] = {"test": t.test.to_json(), "result": tres}
        print(json.encode(res))


class TestDisplayStatus(TestDisplay):
    def show(self):
        d = "["
        complete = True
        if set(self.results.keys()) != self.expected_modules:
            complete = False

        for modname in self.results:
            if modname is not None:
                for tname, t in self.results[modname].items():
                    r = t.result
                    if r is None:
                        complete = False
            else:
                complete = False

        for modname in self.results:
            if modname is not None:
                for tname, t in self.results[modname].items():
                    r = t.result
                    if r is not None:
                        success = r.success
                        if r:
                            d += "."
                        else:
                            d += "!"
                    else:
                        d += " "
        d += "]"
        print("\r", end="", flush=True)
        print(d, end="", flush=True)

        errors = 0
        failures = 0
        if complete:
            print(term.clearline + term.up() + term.clearline, end="")
            tname_width = 20
            for modname in self.results:
                for tname, t in self.results[modname].items():
                    tname_width = max([tname_width, len(t.test.name)], None)

            for modname in self.results:
                if modname == "":
                    print("\nTests")
                else:
                    print("\nTests - module %s:" % modname)
                for tname, t in self.results[modname].items():
                    r = t.result
                    if r is not None:
                        prefix = "  " + t.test.name + ": "
                        prefix += " " * (tname_width - len(prefix))
                        success = r.success
                        exc = r.exception
                        if exc is not None:
                            if success is not None:
                                failures += 1
                                print(prefix + term.bold + term.red + "FAIL (%fms)" % r.duration + term.normal)
                                for line in str(exc).splitlines(None):
                                    print(term.red + "    %s" % (line) + term.normal)
                            else:
                                errors += 1
                                print(prefix + term.bold + term.red + "ERROR (%fms)" % r.duration + term.normal)
                                for line in str(exc).splitlines(None):
                                    print(term.red + "    %s" % (line) + term.normal)
                        else:
                            time = "N/A"
                            if r.duration >= 0:
                                time = "%f" % (r.duration)
                            print(prefix + term.green + "OK (%sms)" % (time) + term.normal)
            print("")
            if errors > 0 and failures > 0:
                print(term.bold + term.red + "%d error and %d failure out of %d tests (%ss)" % (errors, failures, len(self.results), self.sw.elapsed().str_ms()) + term.normal)
                print()
                self._env.exit(2)
            elif errors > 0:
                print(term.bold + term.red + "%d out of %d tests errored (%ss)" % (errors, len(self.results), self.sw.elapsed().str_ms()) + term.normal)
                print()
                self._env.exit(2)
            elif failures > 0:
                print(term.bold + term.red + "%d out of %d tests failed (%ss)" % (failures, len(self.results), self.sw.elapsed().str_ms()) + term.normal)
                print()
                self._env.exit(1)
            else:
                print(term.green + "All %d tests passed (%ss)" % (len(self.results), self.sw.elapsed().str_ms()) + term.normal)
                print()
                self._env.exit(0)

actor test_runner(env: Env, unit_tests: dict[str, UnitTest], sync_actor_tests: dict[str, SyncActorTest], async_actor_tests: dict[str, AsyncActorTest], env_tests: dict[str, EnvTest]):
    sw = time.Stopwatch()
    var results = TestDisplayStatus(env)

    proc def _run_tests(args):
        if args.get_bool("json"):
            results = TestDisplayJSON(env)

        for name, t in unit_tests.items():
            results.update(t, None)
        for name, t in sync_actor_tests.items():
            results.update(t, None)
        for name, t in async_actor_tests.items():
            results.update(t, None)
        for name, t in env_tests.items():
            results.update(t, None)

        results.show()
        # start with unit tests, proceed with next test category after unit tests
        _run_unit_tests(args)

    proc def _run_unit_tests(args):
        hand_out = unit_tests

        def get_test():
            r = hand_out.popitem()
            if r is not None:
                return r.1

        def check_complete():
            if len(hand_out) == 0:
                _run_sync_actor_tests(args)
                return True
            return False

        def report_result(t, test_result: TestResult):
            results.update(t, test_result)
            check_complete()

        if not check_complete():
            for i in range(env.nr_wthreads):
                unit_test_runner(i, get_test, report_result)

    proc def _run_sync_actor_tests(args):
        hand_out = sync_actor_tests

        def get_test() -> ?SyncActorTest:
            r = hand_out.popitem()
            if r is not None:
                return r.1

        def check_complete():
            if len(hand_out) == 0:
                _run_async_actor_tests(args)
                return True
            return False

        def report_result(t, test_result: TestResult):
            results.update(t, test_result)
            check_complete()

        if not check_complete():
            for i in range(0, min([1, env.nr_wthreads // 4], None), 1):
                sync_actor_test_runner(get_test, report_result)

    proc def _run_async_actor_tests(args):
        hand_out = async_actor_tests

        def get_test() -> ?AsyncActorTest:
            r = hand_out.popitem()
            if r is not None:
                return r.1

        def check_complete():
            if len(hand_out) == 0:
                _run_env_tests(args)
                return True
            return False

        def report_result(t, test_result: TestResult):
            results.update(t, test_result)
            check_complete()

        if not check_complete():
            for i in range(0, min([1, env.nr_wthreads // 4], None), 1):
                async_actor_test_runner(get_test, report_result)

    proc def _run_env_tests(args):
        hand_out = env_tests

        def get_test() -> ?EnvTest:
            r = hand_out.popitem()
            if r is not None:
                return r.1

        def check_complete():
            if len(hand_out) == 0:
                # TODO: exit immediately or somethnig?
                return True
            return False

        def report_result(t, test_result: TestResult):
            results.update(t, test_result)

        if not check_complete():
            for i in range(0, min([1, env.nr_wthreads // 4], None), 1):
                env_test_runner(get_test, report_result, env)



    proc def _run_perf_tests(args):
        print("Running performance tests")
        # - disable GC
        acton.rts.disable_gc(env.syscap)

        all_good = True
        for ut in unit_tests.values():
            test_res = []
            try:
                for iteration in range(args.get_int("iterations")):
                    acton.rts.gc(env.syscap) # explicit GC collection
                    mem_before = acton.rts.get_mem_usage(env.syscap)
                    sw = time.Stopwatch()
                    ut.fn() # run test function
                    dur = sw.elapsed().to_float() * 1000.0
                    mem_after = acton.rts.get_mem_usage(env.syscap)
                    gc_sw = time.Stopwatch()
                    acton.rts.gc(env.syscap)
                    gc_dur = gc_sw.elapsed().to_float() * 1000.0
                    mem_usage = mem_after - mem_before
                    test_res.append((dur=dur, gc_dur=gc_dur, mem_usage=mem_usage))

                total_mem_usage = 0
                min_dur = 999999999999.0
                max_dur = 0.0
                total_dur = 0.0
                total_gc_dur = 0.0
                for res in test_res:
                    total_mem_usage += int(res.mem_usage)
                    min_dur = min([min_dur, res.dur], None)
                    max_dur = max([max_dur, res.dur], None)
                    total_dur += res.dur
                    total_gc_dur += res.gc_dur

                avg_mem_usage = total_mem_usage / len(test_res)
                avg_dur = total_dur / float(len(test_res))
                avg_gc_dur = total_gc_dur / float(len(test_res))
                print("Test %s: %sOK%s" % (ut.name, str(term.green), str(term.normal)))
                print("   iterations  : %12d" % args.get_int("iterations"))
                print("   CPU time    : %12f / %12f / %12f ms min/avg/max" % (min_dur, avg_dur, max_dur))
                print("   Mem usage   : %12d bytes (approximate)" % int(avg_mem_usage))
                print("   GC CPU time : %12f ms" % (avg_gc_dur))
            except AssertionError as exc:
                print("Test %s: %sFAILED%s" % (ut.name, term.bold + term.red, term.normal))
                for line in str(exc).splitlines(None):
                    print(term.red + "    %s" % (line) + term.normal)
                all_good = False
            except Exception as exc:
                print("Test %s: %sERROR%s" % (ut.name, term.bold + term.red, term.normal))
                for line in str(exc).splitlines(None):
                    print(term.red + "    %s" % (line) + term.normal)
                all_good = False

        acton.rts.enable_gc(env.syscap)
        if all_good:
            env.exit(0)
        else:
            env.exit(1)

    def _parse_args():
        p = argparse.Parser()
        p.add_bool("json", "Output results as JSON")
        tp = p.add_cmd("test", "Run tests", _run_tests)
        pp = p.add_cmd("perf", "Performance benchmark tests", _run_perf_tests)
        pp.add_option("iterations", "int", "?", 1, "Number of iterations to run")

        args = p.parse(env.argv)
        _cmd = args.cmd
        if _cmd is not None:
            _cmd(args)
        else:
            # no command given, run all tests
            _run_tests(args)
    _parse_args()
