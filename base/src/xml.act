class Node():
    """
A node is an abstract syntax tree for XML.

It is similar to Python's xml.etree.ElementTree.Element.
A node always represent an XML tagged element; so also the children are elements.
Text is represented in the attributes text and tail: in node n,
 - n.text is the string before n's first child;
 - n.tail is the string before n's next sibling.
So, to get the text at top level of node n, one must concatenate
n.text and c.tail for all children of n.
"""
    def __init__(self, tag: str, nsdefs: list[(?str,str)]=[], prefix: ?str=None,
                 attributes: list[(str, str)]=[], children: list[Node]=[], text: ?str=None, tail: ?str=None):
        self.tag = tag
        self.nsdefs = nsdefs
        self.prefix = prefix
        self.attributes = attributes
        self.children = children
        self.text = text
        self.tail = tail

    def encode(self) -> str:
        NotImplemented

    def __repr__(self):
        # Build the arguments to xml.Node() and skip arguments where our value
        # equals the default. We do this with appending to a string because that
        # does not leak the *mut* effect, unlike appending to a list.
        args = repr(self.tag)
        if len(self.nsdefs) != 0:
            args += ", nsdefs={repr(self.nsdefs)}"
        if self.prefix is not None:
            args += ", prefix={repr(self.prefix)}"
        if len(self.attributes) != 0:
            args += ", attributes={repr(self.attributes)}"
        if len(self.children) != 0:
            args += ", children={repr(self.children)}"
        if self.text is not None:
            args += ", text={repr(self.text)}"
        if self.tail is not None:
            args += ", tail={repr(self.tail)}"

        return "xml.Node({args})"


class XmlParseError(ValueError):
    """Exception raised for XML parsing errors

    Attributes:
        line: The line number where the error occurred (if available)
        column: The column number where the error occurred (if available)
    """
    line: ?int
    column: ?int

    def __init__(self, msg: ?str, line: ?int=None, column: ?int=None):
        self.error_message = msg if msg is not None else ""
        self.line = line
        self.column = column

    def __str__(self):
        context = ""
        if self.line is not None:
            context += ":{self.line}"
        if self.column is not None:
            context += ":{self.column}"
        return "{self._name()}{context}: {self.error_message}"

    def __repr__(self):
        return "{self._name()}({repr(self.error_message)}, {repr(self.line)}, {repr(self.column)})"

def decode(data : str) -> Node:
    NotImplemented

# TODO: add arg to pretty-print, default=True
def encode(node : Node) -> str:
    return node.encode()

def toplevel_text(node):
     """Returns the toplevel text in node, as if all subelements were replaced by sep"""
     sep = ' '
     chunks = []
     txt = node.text
     if txt is not None:
         chunks.append(txt)
     for c in node.children:
         tl = c.tail
         if tl is not None:
             chunks.append(tl)
     return sep.join(chunks)
