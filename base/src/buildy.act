import json
import re

"""Buildy stuff

Our projects have a built.act and it collides with this module if it would be
called just 'build', so it's buildy for buildy stuff.
"""

class BuildConfigError(ValueError):
    pass

def zig_safe_name(name: str) -> str:
    m = re.match(r"^[a-zA-Z][a-zA-Z0-9_]*$", name)
    if m is None:
        raise BuildConfigError("Invalid dependency name '%s', must start with a letter and only contain letters, numbers and underscores" % name)
    return name


class BuildConfig(object):
    """Build configuration, the content of build.act.json

    - dependencies are dependencies on other Acton projects
    - zig_dependencies are dependencies on Zig projects, which could in turn be
      Zig, C or C++ libraries that get linked in with the project
    """
    dependencies: dict[str, Dependency]
    zig_dependencies: dict[str, ZigDependency]

    def __init__(self, dependencies: dict[str, Dependency]={}, zig_dependencies: dict[str, ZigDependency]={}):
        self.dependencies = dependencies
        self.zig_dependencies = zig_dependencies

    @staticmethod
    def from_json(data: str):
        jd = json.decode(data)
        new_dependencies = {}
        new_zig_dependencies = {}
        if isinstance(jd, dict):
            for key, value in jd.items():
                if isinstance(key, str):
                    if key == "dependencies":
                        if isinstance(value, dict):
                            for dep_name, dep_attrs in value.items():
                                if isinstance(dep_name, str) and isinstance(dep_attrs, dict):
                                    dep = Dependency.from_json(dep_name, dep_attrs)
                                    new_dependencies[dep_name] = dep
                                else:
                                    raise ValueError("Invalid build.act.json, dependencies should be a dict")
                        else:
                            raise ValueError("Invalid build.act.json, dependencies should be a dict")
                    elif key == "zig_dependencies":
                        if isinstance(value, dict):
                            for dep_name, dep_attrs in value.items():
                                if isinstance(dep_name, str) and isinstance(dep_attrs, dict):
                                    dep = ZigDependency.from_json(dep_name, dep_attrs)
                                    new_zig_dependencies[dep_name] = dep
                                else:
                                    raise ValueError("Invalid build.act.json, zig_dependencies should be a dict")
                        else:
                            raise ValueError("Invalid build.act.json, zig_dependencies should be a dict")
                    else:
                        raise ValueError("Invalid build.act.json, unknown key '%s'" % key)
                else:
                    raise ValueError("Invalid build.act.json, non-string key found in top level dict")


            return BuildConfig(new_dependencies, new_zig_dependencies)
        raise ValueError("Invalid build.act.json, top level should be a dict")

    def to_json(self) -> str:
        res = {
            "dependencies": {},
            "zig_dependencies": {},
        }
        for dep_name, dep in self.dependencies.items():
            res["dependencies"][dep_name] = dep.to_json()
        for dep_name, dep in self.zig_dependencies.items():
            res["zig_dependencies"][dep_name] = dep.to_json()
        return json.encode(res, pretty=True)

class Dependency(object):
    name: str
    url: ?str
    hash: ?str
    path: ?str

    def __init__(self, name: str, url: ?str, hash: ?str, path: ?str):
        self.name = zig_safe_name(name)
        self.url = url
        self.hash = hash
        self.path = path

    @staticmethod
    def from_json(dep_name, data: dict[str, str]):
        dep_url = None
        dep_hash = None
        dep_path = None
        for key, value in data.items():
            if key == "url":
                data_url = data["url"]
                if isinstance(data_url, str):
                    dep_url = data_url
            elif "hash" in data:
                data_hash = data["hash"]
                if isinstance(data_hash, str):
                    dep_hash = data_hash
            elif "path" in data:
                data_path = data["path"]
                if isinstance(data_path, str):
                    dep_path = data_path
            else:
                raise ValueError("Invalid build.act.json, unknown key '%s' in dependency '%s'" % (key, dep_name))
        return Dependency(dep_name, dep_url, dep_hash, dep_path)

    def to_json(self) -> dict[str, str]:
        res = {}
        url = self.url
        if url is not None:
            res["url"] = url
        hash = self.hash
        if hash is not None:
            res["hash"] = hash
        return res

    def to_zon(self) -> str:
        path = ""
        self_path = self.path
        if self_path is not None:
            path = self_path
        else:
            path = ".build/deps/%s" % self.name
        return """        .%s = .{
            .path = "%s"
        },
""" % (
            self.name,
            path
        )


class ZigDependency(object):
    name: str
    url: ?str
    hash: ?str
    options: dict[str, str]
    artifacts: list[str]

    def __init__(self, name: str, url: ?str, hash: ?str, options: dict[str, str], artifacts: list[str]):
        self.name = zig_safe_name(name)
        self.url = url
        self.hash = hash
        self.options = options
        self.artifacts = artifacts

    @staticmethod
    def from_json(dep_name, data: dict[str, str]):
        dep_url: ?str = None
        dep_hash: ?str = None
        dep_options: dict[str, str] = {}
        dep_artifacts: list[str] = []

        for key, value in data.items():
            if key == "url":
                data_url = value
                if isinstance(data_url, str):
                    dep_url = data_url
            elif key == "hash":
                data_hash = value
                if isinstance(data_hash, str):
                    dep_hash = data_hash
            elif key == "options":
                data_options = value
                if isinstance(data_options, dict):
                    dep_options = data_options
            elif key == "artifacts":
                data_artifacts = value
                if isinstance(data_artifacts, list):
                    dep_artifacts = data_artifacts
            else:
                raise ValueError("Invalid build.act.json, unknown key '%s' in dependency '%s'" % (key, dep_name))
        return ZigDependency(dep_name, dep_url, dep_hash, dep_options, dep_artifacts)

    def to_json(self) -> dict[str, str]:
        res = {}
        url = self.url
        if url is not None:
            res["url"] = url
        hash = self.hash
        if hash is not None:
            res["hash"] = hash
        options = self.options
        if len(options) > 0:
            res["options"] = options
        artifacts = self.artifacts
        if len(artifacts) > 0:
            res["artifacts"] = artifacts
        return res

    def to_zon(self) -> str:
        url = self.url
        hash = self.hash
        return """        .%s = .{
            .url = "%s",
            .hash = "%s",
        },
""" % (
            self.name,
            url if url is not None else "",
            hash if hash is not None else "",
        )

def gen_buildzig(template: str, build_config: BuildConfig) -> str:
    deps_defs = ""
    liblink_lines = ""
    exelink_lines = ""

    for dep in build_config.dependencies.values():
        deps_defs += "    const actdep_%s = b.dependency(\"%s\", .{\n" % (dep.name, dep.name)
        deps_defs += "        .target = target,\n"
        deps_defs += "        .optimize = optimize,\n"
        deps_defs += "    });\n"
        liblink_lines += " "*4  + "libActonProject.linkLibrary(actdep_%s.artifact(\"ActonProject\"));\n" % (dep.name)
        exelink_lines += " "*12 + "executable.linkLibrary(actdep_%s.artifact(\"ActonProject\"));\n" % (dep.name)

    for dep_name, dep in build_config.zig_dependencies.items():
        if len(dep.artifacts) > 0:
            deps_defs += "    const dep_%s = b.dependency(\"%s\", .{\n" % (dep.name, dep.name)
            deps_defs += "        .target = target,\n"
            deps_defs += "        .optimize = optimize,\n"
            for key, value in dep.options.items():
                deps_defs += "        .%s = %s,\n" % (key, value)
            deps_defs += "    });\n"
            for artifact in dep.artifacts:
                liblink_lines += " "*4  + "libActonProject.linkLibrary(dep_%s.artifact(\"%s\"));\n" % (dep.name, artifact)
                exelink_lines += " "*12 + "executable.linkLibrary(dep_%s.artifact(\"%s\"));\n" % (dep.name, artifact)

    res = []
    for line in template.split("\n"):
        res.append(line)
        sline = line.strip()
        if sline == "// Dependencies from build.act.json":
            res.append(deps_defs)
        if sline == "// lib: link with dependencies / get headers from build.act.json":
            res.append(liblink_lines)
        if sline == "// exe: link with dependencies / get headers from build.act.json":
            res.append(exelink_lines)

    return "\n".join(res)

def gen_buildzigzon(template: str, build_config: BuildConfig) -> str:
    deps = ""
    for dep_name, dep in build_config.dependencies.items():
        deps += dep.to_zon()
    for dep_name, dep in build_config.zig_dependencies.items():
        deps += dep.to_zon()

    res = []
    for line in template.split("\n"):
        res.append(line)
        sline = line.strip()
        if sline == "// Dependencies from build.act.json":
            res.append(deps)

    return "\n".join(res)
