{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
module Acton.BuildSpec
  ( PkgDep(..)
  , ZigDep(..)
  , BuildSpec(..)
  , parseBuildSpecJSON
  , encodeBuildSpecJSON
  , renderBuildAct
  , parseBuildAct
  , updateBuildActFromJSON
  ) where

import GHC.Generics (Generic)
import Data.Aeson (FromJSON(..), ToJSON(..), (.:?), (.=))
import qualified Data.Aeson as Ae
import qualified Data.ByteString.Lazy as BL
import qualified Data.Map as Map
import Data.Map (Map)
import Data.Maybe (catMaybes, fromMaybe, mapMaybe)
import qualified Data.List as L
import qualified Control.Exception as E
import System.IO.Unsafe (unsafePerformIO)

import Control.Applicative ((<|>))
import qualified Acton.Parser as AP
import qualified Acton.Syntax as S
import qualified Acton.Printer as Pr
import Utils (SrcLoc(..))
import qualified Data.Aeson.KeyMap as KM

-- Acton build configuration data model

-- We use this to specify various bits of information for an Acton project. The
-- canonical way is to have a Build.act file, for example:
--
-- name = "myproject"
--
-- dependencies = {
--   "http2": (repo_url="https://github.com/actonlang/http2", repo_ref="v1.2.3"),
--   "local": (path="deps/local-lib")
-- }
--
-- zig_dependencies = {
--   "zlib": (url="https://example.com/zlib.tar.gz", hash="sha256:deadbeef...", artifacts=["z"]),
--   "ssl": (path="/opt/zig/ssl", options={"with_tls": "true"})
-- }
--

data PkgDep = PkgDep
  { url       :: Maybe String
  , hash      :: Maybe String
  , path      :: Maybe String
  , repo_url  :: Maybe String
  , repo_ref  :: Maybe String
  } deriving (Eq, Show, Generic)

instance FromJSON PkgDep where
  parseJSON = Ae.withObject "PkgDep" $ \o ->
    PkgDep <$> o .:? "url"
           <*> o .:? "hash"
           <*> o .:? "path"
           <*> o .:? "repo_url"
           <*> o .:? "repo_ref"

instance ToJSON PkgDep where
  toJSON (PkgDep u h p ru rr) = Ae.object $ catMaybes
    [ ("url"      .=) <$> u
    , ("hash"     .=) <$> h
    , ("path"     .=) <$> p
    , ("repo_url" .=) <$> ru
    , ("repo_ref" .=) <$> rr
    ]

data ZigDep = ZigDep
  { zurl      :: Maybe String
  , zhash     :: Maybe String
  , zpath     :: Maybe String
  , options   :: Map String String
  , artifacts :: [String]
  } deriving (Eq, Show, Generic)

instance FromJSON ZigDep where
  parseJSON = Ae.withObject "ZigDep" $ \o ->
    ZigDep <$> o .:? "url"
           <*> o .:? "hash"
           <*> o .:? "path"
           <*> (o .:? "options" Ae..!= Map.empty)
           <*> (o .:? "artifacts" Ae..!= [])

instance ToJSON ZigDep where
  toJSON (ZigDep u h p opts arts) = Ae.object $
    catMaybes [ ("url"  .=) <$> u
              , ("hash" .=) <$> h
              , ("path" .=) <$> p
              ] ++
    [ "options"   .= opts
    , "artifacts" .= arts
    ]

data BuildSpec = BuildSpec
  { specName         :: Maybe String
  , specDescription  :: Maybe String
  , dependencies     :: Map String PkgDep
  , zig_dependencies :: Map String ZigDep
  } deriving (Eq, Show, Generic)

instance FromJSON BuildSpec where
  parseJSON = Ae.withObject "BuildSpec" $ \o -> do
    nm   <- o .:? "name"
    desc <- o .:? "description"
    deps <- o .:? "dependencies"     Ae..!= Map.empty
    zig  <- o .:? "zig_dependencies" Ae..!= Map.empty
    return (BuildSpec nm desc deps zig)

instance ToJSON BuildSpec where
  toJSON (BuildSpec nm desc deps zig) = Ae.object $
    catMaybes [ ("name"        .=) <$> nm
              , ("description" .=) <$> desc
              ] ++
    [ "dependencies"     .= deps
    , "zig_dependencies" .= zig
    ]

-- Render an Acton Build.act file from BuildSpec
-- Example:
-- dependencies = {
--   "http2": (repo_url="https://github.com/...", hash="..."),
-- }
-- zig_dependencies = {
--   "zlib": (url="...", hash="...", options={"opt":"val"}, artifacts=["z"]),
-- }

renderBuildAct :: BuildSpec -> String
renderBuildAct (BuildSpec nm mdesc deps zdeps) = unlines $
  [ "# Autogenerated from BuildSpec (actonc)"
  , "# Edit and keep semantics aligned with build.act.json"
  , ""
  ]
  ++ maybe [] (\n -> ["name = " ++ show n]) nm
  ++ maybe [] (\d -> ["description = " ++ show d]) mdesc
  ++ (if nm /= Nothing || mdesc /= Nothing then [""] else [])
  ++ [ renderBlockText "dependencies" deps (Map.keys deps) renderPkgTuple
     , ""
     , ""
     , renderBlockText "zig_dependencies" zdeps (Map.keys zdeps) renderZigTuple
     , ""
     ]

updateBuildActFromJSON :: String -> BL.ByteString -> Either String String
updateBuildActFromJSON content json = do
  (currSpec, mDeps, mZigs) <- parseBuildAct content
  val <- Ae.eitherDecode' json
  case val of
    Ae.Object obj -> do
      spec <- case Ae.fromJSON val of
                Ae.Error e  -> Left e
                Ae.Success s -> Right s
      let depsPresent = KM.member "dependencies" obj
          zigPresent  = KM.member "zig_dependencies" obj
          deps' = if depsPresent then dependencies spec else dependencies currSpec
          zigs' = if zigPresent  then zig_dependencies spec else zig_dependencies currSpec
          merged = BuildSpec { specName         = specName currSpec
                             , specDescription  = specDescription currSpec
                             , dependencies     = deps'
                             , zig_dependencies = zigs' }
          bodyOffsets = Map.fromList $ catMaybes
            [ fmap (\off -> ("dependencies", off)) mDeps
            , fmap (\off -> ("zig_dependencies", off)) mZigs
            ]
      pure $ spliceManyWithBodyOffsets content blockRenderers merged bodyOffsets
    _ -> Left "Expected top-level JSON object for BuildSpec"

-- JSON conversion helpers

parseBuildSpecJSON :: BL.ByteString -> Either String BuildSpec
parseBuildSpecJSON = Ae.eitherDecode'

encodeBuildSpecJSON :: BuildSpec -> BL.ByteString
encodeBuildSpecJSON = Ae.encode

parseBuildAct :: String -> Either String (BuildSpec, Maybe (Int,Int), Maybe (Int,Int))
parseBuildAct content = do
  -- Parse with Acton parser and extract BuildSpec from AST
  modAST <- parseModuleForSpec content
  let specFromAST = extractSpecFromModule modAST
  -- Compute body offsets using AST locations
  let mDepsOff = findBodyOffsetsFromAST content "dependencies" modAST
      mZigsOff = findBodyOffsetsFromAST content "zig_dependencies" modAST
  Right (specFromAST, mDepsOff, mZigsOff)

-- Find the inner-body offsets (start,end) between braces of the dict assigned
-- to a given top-level variable, using AST locations only. The returned range
-- is the content between '{' and '}', excluding the braces themselves.
findBodyOffsetsFromAST :: String -> String -> S.Module -> Maybe (Int,Int)
findBodyOffsetsFromAST content varName (S.Module _ _ stmts) =
  case firstDictLoc stmts of
    Just (s,e) -> braceBody content s e
    Nothing    -> Nothing
  where
    firstDictLoc [] = Nothing
    firstDictLoc (S.Assign _ [S.PVar _ (S.Name _ v) _] (S.Dict l _) : rest)
      | v == varName = srcLocToPair l <|> firstDictLoc rest
    firstDictLoc (_:rest) = firstDictLoc rest

    srcLocToPair NoLoc     = Nothing
    srcLocToPair (Loc s e) = Just (s,e)

    -- Given a range [s,e) covering the dict, return the inner body [s+1,e-1].
    -- We assume the Acton parser locates the Dict to start at '{' and end
    -- just after '}'. If that is not the case, we conservatively return Nothing.
    braceBody txt s e =
      let n = length txt
      in if s >= 0 && e <= n && s+1 <= e-1 && txt !! s == '{' && txt !! (e-1) == '}'
           then Just (s+1, e-1)
           else Nothing
    
-- Parse build.act using the real Acton parser
parseModuleForSpec :: String -> Either String S.Module
parseModuleForSpec content =
  let qn = S.ModName []  -- anonymous module
  in case unsafePerformIO (E.try (AP.parseModule qn "Build.act" content) :: IO (Either E.SomeException S.Module)) of
       Left e  -> Left (show e)
       Right m -> Right m

-- Extract name, description, dependencies and zig_dependencies from the AST
extractSpecFromModule :: S.Module -> BuildSpec
extractSpecFromModule (S.Module _ _ stmts) =
  let (mname, mdesc, deps, zigs) = foldl step (Nothing, Nothing, Map.empty, Map.empty) stmts
  in BuildSpec { specName = mname, specDescription = mdesc, dependencies = deps, zig_dependencies = zigs }
  where
    step (mname, mdesc, deps, zigs) stmt = case stmt of
      S.Assign _ pats expr ->
        let names = mapMaybe patternVarName pats
            mname' = if "name" `elem` names
                       then exprToSimpleString expr <|> mname
                       else mname
            mdesc' = if "description" `elem` names
                       then exprToSimpleString expr <|> mdesc
                       else mdesc
            deps'  = if "dependencies" `elem` names
                       then fromMaybe deps (exprToPkgDeps expr)
                       else deps
            zigs'  = if "zig_dependencies" `elem` names
                       then fromMaybe zigs (exprToZigDeps expr)
                       else zigs
        in (mname', mdesc', deps', zigs')
      _ -> (mname, mdesc, deps, zigs)

    patternVarName :: S.Pattern -> Maybe String
    patternVarName (S.PVar _ (S.Name _ v) _) = Just v
    patternVarName (S.PParen _ p)            = patternVarName p
    patternVarName _                         = Nothing


-- Generic block rendering and splicing -------------------------------------------------

-- Order here defines append order for missing blocks.
type BlockDef = (String, BuildSpec -> [String], BuildSpec -> String)

blockRenderers :: [BlockDef]
blockRenderers =
  [ ( "dependencies"
    , \spec -> Map.keys (dependencies spec)
    , \spec -> renderBlockText "dependencies" (dependencies spec) (Map.keys (dependencies spec)) renderPkgTuple
    )
  , ( "zig_dependencies"
    , \spec -> Map.keys (zig_dependencies spec)
    , \spec -> renderBlockText "zig_dependencies" (zig_dependencies spec) (Map.keys (zig_dependencies spec)) renderZigTuple
    )
  ]

-- Splice multiple blocks by label using precomputed inner-body offsets.
-- Replaces present blocks in-place (preserving surrounding text) and appends
-- any missing non-empty blocks at the end in declared order.
spliceManyWithBodyOffsets :: String -> [BlockDef] -> BuildSpec -> Map.Map String (Int,Int) -> String
spliceManyWithBodyOffsets content defs spec bodyOffsets =
  let reps = [ (s,e, (if s < length content && content !! s == '\n' then "\n" else "") ++ renderInner lbl)
             | (lbl,_,_) <- defs
             , Just (s,e) <- [Map.lookup lbl bodyOffsets]
             ]
      missing = [ renderFull lbl
                | (lbl, keysFn, _) <- defs
                , Map.notMember lbl bodyOffsets
                , not (null (keysFn spec))
                ]
      replaced = applyReplacements' content (L.sortOn (\(s,_,_) -> s) reps)
      appended = if null missing then replaced else appendBlocks' replaced missing
  in appended
  where
    renderInner lbl = case lookup lbl [(l, keysFn) | (l, keysFn, _renderer) <- defs] of
                        Just keysFn -> renderInnerBlock lbl (keysFn spec)
                        Nothing     -> ""
    renderFull lbl = case lookup lbl [(l, renderer) | (l, _keysFn, renderer) <- defs] of
                       Just renderer -> renderer spec
                       Nothing       -> ""
    renderInnerBlock lbl keys
      | lbl == "dependencies"     = renderInnerText (dependencies spec) keys renderPkgTuple
      | lbl == "zig_dependencies" = renderInnerText (zig_dependencies spec) keys renderZigTuple
      | otherwise = ""

-- Render only the inner lines of a dict block, no label/braces
renderInnerText :: (Show k, Ord k) => Map k v -> [k] -> (v -> String) -> String
renderInnerText m keys renderTuple =
  let total = length keys
      comma i = if i < total then "," else ""
      lines' = [ "    " ++ show k ++ ": " ++ renderTuple (m Map.! k) ++ comma i
               | (i,k) <- zip [1..] keys ]
  in unlines lines'

    -- Local helpers (replacements and append)
applyReplacements' :: String -> [(Int,Int,String)] -> String
applyReplacements' txt reps =
  let go pos acc [] = acc ++ drop pos txt
      go pos acc ((s,e,newT):xs) =
        let pre = take (s - pos) (drop pos txt)
        in go e (acc ++ pre ++ newT) xs
  in go 0 "" reps

appendBlocks' :: String -> [String] -> String
appendBlocks' txt blks =
  let base = if lastLineEndsNewline' txt then txt else txt ++ "\n"
  in base ++ L.intercalate "\n" blks

lastLineEndsNewline' :: String -> Bool
lastLineEndsNewline' s = not (null s) && last s == '\n'

-- Rendering helpers

renderBlockText :: (Show k, Ord k) => String -> Map k v -> [k] -> (v -> String) -> String
renderBlockText label m keys renderTuple =
  let lines' = [ "  " ++ show k ++ ": " ++ renderTuple (m Map.! k) ++ comma i
               | (i,k) <- zip [1..] keys ]
  in unlines $ [label ++ " = {"] ++ lines' ++ ["}"]
  where
    comma i = if i < length keys then "," else ""

renderExpr :: S.Expr -> String
renderExpr e = Pr.render (Pr.pretty e)

-- Turn a PkgDep into a multi-line parenthesized key=value tuple string, e.g.:
-- (
--     key1="val1",
--     key2="val2"
-- )
renderPkgTuple :: PkgDep -> String
renderPkgTuple (PkgDep u h p ru rr) =
  let fields = catMaybes
        [ fmap (\x -> ("repo_url", mkStr x)) ru
        , fmap (\x -> ("repo_ref", mkStr x)) rr
        , fmap (\x -> ("url", mkStr x)) u
        , fmap (\x -> ("hash", mkStr x)) h
        , fmap (\x -> ("path", mkStr x)) p
        ]
  in case fields of
       [] -> "()"
       _  ->
         let total = length fields
             fieldLines = [ "        " ++ k ++ "=" ++ renderExpr v ++ comma i
                          | (i, (k,v)) <- zip [1..] fields ]
             comma i = if i < total then "," else ""
         in "(\n" ++ L.intercalate "\n" fieldLines ++ "\n    )"

-- Turn a ZigDep into a multi-line parenthesized key=value tuple string
renderZigTuple :: ZigDep -> String
renderZigTuple (ZigDep u h p opts arts) =
  let optExpr = if Map.null opts then Nothing else Just (mkOptions opts)
      artExpr = if null arts then Nothing else Just (mkList arts)
      fields = catMaybes
        [ fmap (\x -> ("url", mkStr x)) u
        , fmap (\x -> ("hash", mkStr x)) h
        , fmap (\x -> ("path", mkStr x)) p
        , fmap (\x -> ("options", x)) optExpr
        , fmap (\x -> ("artifacts", x)) artExpr
        ]
  in case fields of
       [] -> "()"
       _  ->
         let total = length fields
             fieldLines = [ "        " ++ k ++ "=" ++ renderExpr v ++ comma i
                          | (i, (k,v)) <- zip [1..] fields ]
             comma i = if i < total then "," else ""
         in "(\n" ++ L.intercalate "\n" fieldLines ++ "\n    )"

-- Compose a tuple string with no spaces around '=' and comma+space between pairs
renderTuple :: [(String, S.Expr)] -> String
renderTuple pairs =
  let items = [ k ++ "=" ++ renderExpr v | (k,v) <- pairs ]
  in "(" ++ L.intercalate ", " items ++ ")"

-- Minimal Expr builders used for value rendering
mkStr :: String -> S.Expr
mkStr s = S.Strings NoLoc [s]
mkOptions :: Map String String -> S.Expr
mkOptions mp = S.Dict NoLoc [ S.Assoc (mkStr k) (mkStr v) | (k,v) <- Map.toList mp ]
mkList :: [String] -> S.Expr
mkList xs = S.List NoLoc [ S.Elem (mkStr x) | x <- xs ]


exprToSimpleString :: S.Expr -> Maybe String
exprToSimpleString (S.Strings _ [s]) = Just s
exprToSimpleString _ = Nothing

exprToPkgDeps :: S.Expr -> Maybe (Map.Map String PkgDep)
exprToPkgDeps (S.Dict _ assocs) = Just $ Map.fromList (mapMaybe assocToPkg assocs)
  where
    assocToPkg (S.Assoc k v) = do
      key <- exprToSimpleString k
      dep <- tupleToPkg v
      pure (key, dep)
    assocToPkg _ = Nothing
exprToPkgDeps _ = Nothing

tupleToPkg :: S.Expr -> Maybe PkgDep
tupleToPkg (S.Tuple _ _ kargs) =
  let m = kwdToMap kargs
  in Just PkgDep { url = Map.lookup "url" m >>= exprToSimpleString
                 , hash = Map.lookup "hash" m >>= exprToSimpleString
                 , path = Map.lookup "path" m >>= exprToSimpleString
                 , repo_url = Map.lookup "repo_url" m >>= exprToSimpleString
                 , repo_ref = Map.lookup "repo_ref" m >>= exprToSimpleString
                 }
tupleToPkg (S.Paren _ e) = tupleToPkg e
tupleToPkg _ = Nothing

exprToZigDeps :: S.Expr -> Maybe (Map.Map String ZigDep)
exprToZigDeps (S.Dict _ assocs) = Just $ Map.fromList (mapMaybe assocToZig assocs)
  where
    assocToZig (S.Assoc k v) = do
      key <- exprToSimpleString k
      dep <- tupleToZig v
      pure (key, dep)
    assocToZig _ = Nothing
exprToZigDeps _ = Nothing

tupleToZig :: S.Expr -> Maybe ZigDep
tupleToZig (S.Tuple _ _ kargs) =
  let m = kwdToMap kargs
  in Just ZigDep { zurl = Map.lookup "url" m >>= exprToSimpleString
                 , zhash = Map.lookup "hash" m >>= exprToSimpleString
                 , zpath = Map.lookup "path" m >>= exprToSimpleString
                 , options = fromMaybe Map.empty (Map.lookup "options" m >>= exprToOptions)
                 , artifacts = fromMaybe [] (Map.lookup "artifacts" m >>= exprToListStrings)
                 }
tupleToZig (S.Paren _ e) = tupleToZig e
tupleToZig _ = Nothing

kwdToMap :: S.KwdArg -> Map.Map String S.Expr
kwdToMap S.KwdNil = Map.empty
kwdToMap (S.KwdArg (S.Name _ n) e rest) = Map.insert n e (kwdToMap rest)
kwdToMap (S.KwdStar _) = Map.empty

exprToOptions :: S.Expr -> Maybe (Map.Map String String)
exprToOptions (S.Dict _ assocs) = Just $ Map.fromList (mapMaybe kv assocs)
  where kv (S.Assoc k v) = do
          key <- exprToSimpleString k <|> (case k of { S.Var _ (S.NoQ n) -> Just (S.nstr n); _ -> Nothing })
          val <- exprToSimpleString v
          pure (key, val)
        kv _ = Nothing
exprToOptions _ = Nothing

exprToListStrings :: S.Expr -> Maybe [String]
exprToListStrings (S.List _ elems) = Just $ mapMaybe elemStr elems
  where elemStr (S.Elem e) = exprToSimpleString e
        elemStr _ = Nothing
exprToListStrings _ = Nothing

-- No fallback text parsing; we rely on the AST exclusively for semantics and
-- use source locations only to find brace body spans for splicing.
