# Test stdlib net module by first starting a server which listens to a TCP port
# and then creating a TCP client connection which connects to the server, sends
# a message and expects a reply. This exercices both ends of the TCP connection.

import acton.rts
import net
import random


def get_tcp_handles(m):
    tcp_handles = m.io_handles()
    res = {}
    for wthread_id, handles in tcp_handles.items():
        for k, v in handles.items():
            if v.typ == "tcp" and v.act != u64(0):
                res[k] = v
    return res

actor Server(conn):
    def on_receive(c, data):
        print("Server received some data:", data, " from:", c)
        if data == b"PING":
            c.write(b"PONG")
            c.close()

    def on_error(c, error):
        print("There was an error:", error, " from:", c)


actor Listener(env, port):
    def on_lsock_error(l, error):
        print("There was an error with the TCPListener socket:", error)

    def on_server_accept(c):
        s = Server(c)
        c.cb_install(s.on_receive, s.on_error)

    listen_cap = net.TCPListenCap(net.TCPCap(net.NetCap(env.cap)))
    server = net.TCPListener(listen_cap, "0.0.0.0", port, on_lsock_error, on_server_accept)


actor Client(rts_monitor, env: Env, port: int):
    var connection = 0
    def on_connect(c):
        connection += 1
        print("Client connected, TCP handles", get_tcp_handles(rts_monitor))
        await async c.write(b"PING")

    def on_close(c):
        print("closed connection", connection)
        if connection == 2:
            after 0.001: check_io()

    def check_io():
        tcp_handles = get_tcp_handles(rts_monitor)
        print("IO check...", tcp_handles)
        if len(tcp_handles) < 2:
            # Only TCP listening socket left...
            print("TCP client properly cleaned from IO loop, exiting...")
            await async env.exit(0)
        else:
            print("TCP client not properly cleaned from IO loop, waiting...")
            after 0.8: check_io()

    def on_receive(c, data):
        print("Client RECV", data)
        if data == b"PONG":
            print("Got PONG, all good, yay")
            if connection == 1:
                print("Conn 1: reconnecting")
                c.reconnect()
            else:
                # Test idempotency / that we don't break anything by double-closing
                c.close(on_close)
                await async c.close(on_close)
        else:
            print("Got bad response, exiting with error..")
            await async env.exit(1)

    def on_error(c, msg):
        print("Client ERR", msg)

    def _exit():
        print("exiting..")
        await async env.exit(0)

    connect_cap = net.TCPConnectCap(net.TCPCap(net.NetCap(env.cap)))
    client = net.TCPConnection(connect_cap, "localhost", port, on_connect, on_receive, on_error)


actor main(env):
    def timeout_error():
        print("Timeout reached, exiting with error...")
        await async env.exit(1)

    after 2: timeout_error()

    port = random.randint(10000, 20000)
    print("Using port", port)
    rts_monitor = acton.rts.Monitor(env)
    l = Listener(env, port)
    c = Client(rts_monitor, env, port)
