import net
import process
import testing


actor TLSClient(env: Env, host: str, port: int, on_success, on_failure):
    var done = False

    def _finish_success():
        if not done:
            done = True
            on_success()

    def _finish_failure(msg: str):
        if not done:
            done = True
            on_failure(msg)

    def on_connect(c):
        await async c.write(b"PING")

    def on_receive(c, data):
        if data == b"PONG":
            _finish_success()
            c.close(lambda c: None)
        else:
            _finish_failure("Unexpected response: " + str(data))

    def on_error(c, msg):
        _finish_failure("TLS client error: " + msg)

    def on_remote_close(c):
        _finish_failure("TLS server closed before response")

    connect_cap = net.TCPConnectCap(net.TCPCap(net.NetCap(env.cap)))
    client = net.TLSConnection(connect_cap, host, port, on_connect, on_receive, on_error, on_remote_close, False)


actor _TLSClientServer(t: testing.EnvT):
    pc = process.ProcessCap(t.env.cap)
    server_bin = "../stdlib/tls_test_server"

    var done = False
    var server_proc: ?process.Process = None
    var buf = ""
    var started = False

    def _finish_success():
        if done:
            return
        done = True
        if server_proc is not None:
            server_proc.stop()
        t.success()

    def _finish_failure(msg: str):
        if done:
            return
        done = True
        if server_proc is not None:
            server_proc.stop()
        t.failure(AssertionError(msg))

    def _finish_error(msg: str):
        if done:
            return
        done = True
        if server_proc is not None:
            server_proc.stop()
        t.error(Exception(msg))

    def _on_client_success():
        _finish_success()

    def _on_client_failure(msg: str):
        _finish_failure(msg)

    def _start_client(port: int):
        TLSClient(t.env, "127.0.0.1", port, _on_client_success, _on_client_failure)

    def _handle_server_stdout(data: bytes):
        if started:
            return
        buf += data.decode()
        idx = buf.find("READY ")
        if idx == -1:
            return
        rest = buf[idx + 6:]
        end = rest.find("\n")
        if end == -1:
            return
        started = True
        _start_client(int(rest[:end].strip()))

    def _on_server_stdout(p, data):
        if data is not None:
            _handle_server_stdout(data)

    def _on_server_exit(p, exit_code, term_signal):
        if done:
            return
        _finish_error("TLS server exited (code %d, signal %d)" % (exit_code, term_signal))

    def _on_server_error(p, error):
        if done:
            return
        _finish_error("TLS server error: " + error)

    def _timeout():
        _finish_error("timeout")

    server_proc = process.Process(
        pc,
        [server_bin, "--port", "0", "--connections", "0"],
        _on_server_stdout,
        lambda p, data: None,
        _on_server_exit,
        _on_server_error
    )
    after 10: _timeout()


def _test_net_tls(t: testing.EnvT):
    _TLSClientServer(t)
