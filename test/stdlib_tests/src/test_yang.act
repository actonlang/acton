import testing
import yang.parser
import yang.schema

test_yang = """module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
  description "test yang module";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
  import ietf-inet-types {
    prefix "inet";
    revision-date 2013-07-15;
  }
  include example-types;
  feature fe1 {
    description "feature 1";
  }
  feature fe2 {
    description "feature 2";
  }
  typedef t1 {
    type string;
  }
  identity i1 {
    description "identity 1";
  }
  identity i1c {
    description "identity 1";
    base i1;
  }
  extension ext1 {
    description "extension 1";
    argument "arg1";
  }
  grouping g1 {
    description "grouping 1";
    leaf gl1 {
      type string;
      description "grouping leaf 1";
    }
  }
  grouping g2 {
    description "grouping 2";
    container gc1 {
      description "empty container";
    }
  }
  container c1 {
    description "container 1";
    leaf l1 {
      type string;
      description "leaf 1";
      if-feature "fe1 or fe2";
    }
    container c2 {
      description "container 2";
      config false;
      leaf l2 {
        type string;
        description "leaf 2";
      }
      uses g1;
      uses g2 {
        augment "gl2" {
          leaf al1 {
            type string;
          }
        }
        refine "gl2" {
          if-feature "foo";
          description "refined description for gl2";
        }
      }
    }
  }
  container c3 {
    action a1 {
      description "action 1";
    }
    list li1 {
      description "list 1";
    }
    leaf-list lli1 {
      description "leaf-list 1";
      type int32;
    }
    choice ch1 {
      description "choice 1";
    }
  }
  rpc rpc1 {
    description "rpc 1";
    input {
      leaf rli1 {
        type string;
        description "rpc input leaf 1";
      }
    }
    output {
      leaf rlo1 {
        type string;
        description "rpc output leaf 1";
      }
    }
  }
  notification n1 {
    description "notification 1";
    anydata n1ad {
      description "notification anydata 1";
    }
    anyxml n1ax {
      description "notification anyxml 1";
    }
  }
}
"""

test_submodule = """submodule test_submodule {
  belongs-to test_yang {
    prefix "sub1";
  }
}
"""

def mwrap(s):
    """Wrap some YANG in a module definition"""
    header = """module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
"""
    footer = """
}
"""
    return header + s + footer


def _test_yang():
    original = test_yang
    y = yang.parser.parse(original)
    yang_out = y.pryang()
    testing.assertEqual(original, yang_out, "YANG round trip failed\n" + original + "\n===\n" + yang_out)

def _test_submodule():
    original = test_submodule
    y = yang.parser.parse(original)
    yang_out = y.pryang()
    testing.assertEqual(original, yang_out, "YANG round trip failed\n" + original + "\n===\n" + yang_out)

def _test_prsrc():
    y = yang.parser.parse(test_yang)
    n = yang.schema.stmt_to_snode(y)
    src_out = n.prsrc()

def _test_schema_node():
    y = yang.parser.parse(test_yang)
    n = yang.schema.stmt_to_snode(y)

def _test_schema_node_submodule():
    y = yang.parser.parse(test_submodule)
    n = yang.schema.stmt_to_snode(y)

def _test_fail_leaf_invalid():
    """Invalid statement under leaf"""
    t = mwrap("""leaf l1 {
  type string;
  description "leaf 1";
  foo "bar";
}
""")
    try:
        y = yang.parser.parse(t)
    except ValueError as exc:
        testing.assertEqual("Invalid statement under leaf", str(exc), "Expected ValueError")
        return

actor main(env):
    y = yang.parser.parse(test_yang)
    print("YANG printed from statements:")
    print(y.pryang())
    n = yang.schema.stmt_to_snode(y)
    print("Acton source code for YANG schema node:")
    print(n.prsrc())
    env.exit(0)
